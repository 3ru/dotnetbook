# Структура объектов в памяти

До сих, говоря про разницу между значимыми и ссылочными типами, мы затрагивали эту тему с высоты конечного разработчика. Т.е. мы не смотрели на то как они в реальности устроены на уровне CLR, как сделаны те или иные механики внутри каждого из них. Мы смотрели фактически на конечный результат. Однако, чтобы понимать суть вещей глубже и чтобы отбросить в сторону последние оставшиеся мысли о какой-либо магии, происходящей внутри CLR стоит заглянуть в самые ее потроха.

## Внутренняя структура экземпляров типов

Если говорить о классах как о типах данных, то в разговоре об их типах данных достаточно вспомнить их базовое устройство. Давайте начнем с типа `object`, который является базовым типом и формирует структуру для всех ссылочных типов:

**System.Object**:
```

  ----------------------------------------------
  |  SyncBlkIndx |    VMTPtr    |     Data     |
  ----------------------------------------------
  |  4 / 8 байт  |  4 / 8 байт  |  4 / 8 байт  |
  ----------------------------------------------
  |      -1      |  0xXXXXXXXX  |      0       |
  ----------------------------------------------

  Sum size = 12 (x86) .. 24 (x64)
```

Т.е. размер фактически зависит от конечной платформы, на которой быдет работать приложение. 

Теперь чтобы получить дальнейшее понимание, с чем мы имеем дело давайте проследуем по указателю `VMTPtr`. Для всей системы типов этот указатель является самым главным: именно через него работает и наследование, и реализация интерфейсов и приведение типов и много чего еще. Этот указатель - отсылка в систему типов .NET CLR.

### Virtual Methods Table

 Описание самой таблицы доступно по адресу в [GitHub CoreCLR](https://github.com/dotnet/coreclr/blob/master/src/vm/methodtable.h) и если отбросить все лишнее (а там 4381 строка! Парни из CoreCLR team не из пугливых), [выглядит она следующим образом](https://github.com/dotnet/coreclr/blob/master/src/vm/methodtable.h#L4099-L4114):

> Это версия из CoreCLR. Если смотреть на структуру полей в .NET Framework, то она будет отличаться расположением полей.

 ```cpp
    // Low WORD is component size for array and string types (HasComponentSize() returns true).
    // Used for flags otherwise.
    DWORD m_dwFlags;

    // Base size of instance of this class when allocated on the heap
    DWORD m_BaseSize;

    WORD  m_wFlags2;

    // Class token if it fits into 16-bits. If this is (WORD)-1, the class token is stored in the TokenOverflow optional member.
    WORD  m_wToken;
        
    // <NICE> In the normal cases we shouldn't need a full word for each of these </NICE>
    WORD  m_wNumVirtuals;
    WORD  m_wNumInterfaces;
 ```

 Согласитесь, выглядит пугающе. Причем пугающе не в том что тут всего 6 полей (а где все остальные?), а в том что для того чтобы до них добаться, нам надо было пропустить 4,100 строк логики. Но давайте не будем унывать и попытаемся сразу получить из этого выгоду: мы пока что понятия не имеем что имеется ввиду под другими полями, зато поле `m_BaseSize` выглядит заманчиво. Как подсказывает нам комментарий, это - фактический размер для экземпляра типа. Попробуем в бою?

 Чтобы получить адрес VMT мы можем пойти двумя путями: либо зайти со сложного конца, получив адрес объекта, а значит и VMT (этот код уже был на страницах этой книги, но не ругайте меня: я не хочу чтобы вы его искали):

 ```csharp
class Program
{
    public static unsafe void Main()
    {
        Union x = new Union();
        x.Reference.Value = "Hello!";

        // Первым полем лежит указатель на место, где лежит
        // указатель на VMT
        // - (IntPtr*)x.Value.Value - преобразовали число в указатель (сменили тип для компилятора)
        // - *(IntPtr*)x.Value.Value - взяли по адресу объекта адрес VMT
        // - (void *)*(IntPtr*)x.Value.Value - преобразовали в указатель
        void *vmt = (void *)*(IntPtr*)x.Value.Value;

        // вывели в консоль адрес VMT;
        Console.WriteLine((ulong)vmt); 
    }

    [StructLayout(LayoutKind.Explicit)]
    public class Union
    {
        public Union()
        {
            Value = new Holder<IntPtr>();
            Reference = new Holder<object>();
        }

        [FieldOffset(0)]
        public Holder<IntPtr> Value;
        
        [FieldOffset(0)]
        public Holder<object> Reference;
    }

    public class Holder<T>
    {
        public T Value;
    }
}
 ```

Либо тот же самый адрес возвращается вполне себе .NET FCL API: 

```csharp
    var vmt = typeof(string).TypeHandle.Value;
```

Второй путь конечно же проще (хоть и дольше работает). Однако знание первого очень важно с точки зрения понимания структуры экземпляра типа. Пользование вторым путем хоть и добавляет чувства уверенности: если мы вызываем метод API, то вроде как пользуемся задокументированным способом работы с VMT. А если достаем через указатели, то нет. Но не стоит забывать что хранение `VMT *` - стандартно для практически любого ООП языка: она всегда находится на одном и том же месте. 

Давайте изучим вопрос структуры типов с точки зрения размера их экземпляра. Нам же надо не просто абстрактно изучать их (это просто-напросто скучно), но дополнительно попробуем извлечь из этого такую выгоду, какую не извлечь обычным способом.

> **Почему sizeof есть для Value Type но нет для Reference Type?** На самом деле вопрос открытый т.к. никто не мешает рассчитать размер ссылочного типа. Единственное обо что можно споткнуться - это не фиксированный размер двух ссылочных типов: `Array` и `String`. А также `Generic` группы, которая зависит целиком и полностью от конкреных вариантов. Т.е. оператором `sizeof(..)` мы обойтись не смогли бы: необходимо работать с конкретными экземплярами. Однако никто не машает сделать метод типа `static int System.Object.SizeOf(object obj)`, который бы легко и просто возвращал бы нам то что надо. Так почему же Microsoft не реализовала этот метод? Есть мысль что платорма .NET в их понимании не та платформа, где разработчик будет сильно переживать за конкретные байты. В случае чего можно просто доставить планок в материнскую плату. Тем более что большинство типов данных, которые мы реализуем на занимает такие большие объемы. Однако тем, кому нужно все что нужно подсчитают все размеры так как надо. Последнее, конечно, спорно. 

Но не будем отвлекаться. Итак, чтобы получить размер экземпляра либого класса, экземпляры которого имеют фиксированный размер достаточно насписать следующий код:

```csharp
unsafe int SizeOf(Type type)
{
    MethodTable *pvmt = (MethodTable *)type.TypeHandle.Value.ToPointer();    
    return pvmt->Size;
}

[StructLayout(LayoutKind.Explicit)]
public struct MethodTable
{
    [FieldOffset(4)]
    public int Size;
}

class Sample
{
    int x;
}

class GenericSample<T>
{
	T fld;
}
// ...

Console.WriteLine(SizeOf(typeof(Sample)));
```

Итак, что мы только что сделали? Первым шагом мы получили указатель на таблицу виртуальных методов. Далее привели тип к указателю на таблицу виртуальных методов (очень упрощенная её версия). После чего мы считываем размер и получаем `12` - это сумма размеров полей `SyncBlockIndex + VMT_Ptr + поле x` на 32-разрядной платформы. Если мы поиграемся с разными типами то получим примерно следующую таблицу:

Тип или его определение | Размер    | Комментарий
------------------------|-----------|--------------
Object | 12 | SyBlk + VMT + пустое поле
Int16 | 12 | Boxed Int16: SyBlk + VMT + данные (выровнено по 4 байта на x86)
Int32 | 12 | Boxed Int32: SyBlk + VMT + данные
Int64 | 16 | Boxed Int64: SyBlk + VMT + данные
Char | 12 |  Boxed Char: SyBlk + VMT + данные (выровнено по 4 байта на x86)
Double | 16 | Boxed Double: SyBlk + VMT + данные
IEnumerable | 0 | Интерфейс не имеет размера: надо брать obj.GetType()
List<T> | 24 | Не важно сколько элементов в List<T>, занимать он будет одинаково т.к. хранит данные он в array, который не учитывается
GenericSample<int> | 12 | Как видите, generics прекрасно считаются. Размер не поменялся, т.к. данные находятся на том же месте что и у boxed int. Итог: SyBlk + VMT + данные = 12 байт (x86)
GenericSample<Int64> | 16 | Аналогично
GenericSample<IEnumerable> | 12 | Аналогично
GenericSample<DateTime> | 16 | Аналогично

Как видите, когда система хранит данные, то она фактически хранит данные для ссылочного типа (в том числе для ссылочного варианта значимого).