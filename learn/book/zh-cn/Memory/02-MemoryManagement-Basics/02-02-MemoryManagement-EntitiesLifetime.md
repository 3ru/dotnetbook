# 实体的生命周期

一个可能会对我们应用程序的性能产生很大影响的问题是实体类型的选择策略：类还是结构体，以及对它们的生命周期进行控制。毕竟，平台的架构师们之所以为我们提供了这两种数据类型，不是没有原因的。这种区分首先是基于应用程序优化的可能性，其架构考虑了这两组类型的特点。

[>]: 这两个词：结构体和类，我敢打赌，会让很多人感到恐惧，并且心里暗自问：“又来了吗？...”。然而，请相信我：在阅读本书的过程中，您和我一样会对它们的特性产生共鸣。

正如在[引用类型与值类型数据](../ReferenceTypesVsValueTypes.md)一章中所述，值类型的巨大优势在于它们不需要分配内存。换句话说，如果某个值类型的实例位于局部变量或方法参数中，那么它的位置就在堆栈上（而不是在堆上分配额外的内存）。这是一个值得梦寐以求的操作，因为它是最快且最有效的。如果结构体位于引用类型（类）的字段中，那么也不会调用分配内存的操作：因为它是引用类型的结构部分，实际上是与引用类型的分配一起进行的（作为其一部分进行分配）。然而，引用类型的情况要复杂得多。因为如果涉及到引用类型，那么在为它们的实例分配内存时会遇到一系列复杂性。更糟糕的是，我们几乎无法控制我们将遇到哪种内存分配算法：无论是最快的四种算法中的哪一种，还是最重的一种。

## 引用类型的生命周期

### 总览

为了更全面地了解引用类型实例的生命周期特点，请继续阅读。引用类型在其自身生命周期方面具有以下特点：

  - 与值类型不同，引用类型具有确定的生命周期开始。换句话说，它们只有在某人通过`new`操作符请求它们的创建时才会生成；
  - 然而，它们具有非确定性的释放：我们不知道何时会释放它们所占用的内存。即使对于`Large Objects Heap`，我们也无法为特定实例调用GC，即使这个操作在某些情况下是合理的；

这两个特性给我们带来了一些思考：

  - 类的实例在不确定的将来的某个时间被销毁；
  - 它们的销毁是由对它们的引用丢失引起的；
  - 因此，从一方面来说，这意味着将最后一个引用对象的操作转变为应用程序范围内的确定性操作。对象仍然存在，但对整个应用程序来说是不可访问的；
  - 然而，从另一方面来说，我们并不总是知道哪个引用的置零操作将是最后一个，这使我们在置零最后一个引用方面失去了确定性。

另一个非常重要的特性是对象具有虚拟的终结方法。这个方法在垃圾收集器触发时调用，也就是在不确定的将来的某个时间。而且，这个方法只是为了正确关闭对象所拥有的非托管资源，只有在某些情况下才会调用（例如，抛出了未处理的异常，导致无法调用`Dispose()`，并且程序无法自行完成释放这些资源的代码）。由于调用该方法的时间和释放对象所占用的内存与我们无关，因此该调用也不是确定性的。更糟糕的是，它是异步的，因为它在应用程序执行期间的单独线程中执行。这一点很重要，因为如果您的应用程序具有重新尝试使用资源的逻辑，并且发生了某些错误（例如，`ThreadAbortException`），导致在上一次尝试的结果中没有调用`Dispose()`，并且资源在终结队列中“挂起”，那么这意味着在该终结队列完成之前，您将无法打开该资源（例如，文件）。

> 然而，当存在不确定性时，程序员总是希望带来确定性，因此产生了`IDisposable`接口，稍后在下一章中将讨论。我现在只能说一件事：它的实现是必要的，以便外部代码可以自行释放对象的资源。换句话说，确定性地通知对象它不再需要了。

因此，从使用对象的程序员的角度来看，对象的破坏是一种伪确定性的行为：通过调用`Dispose()`方法将对象转换为破坏状态。内存不会被释放，对象的引用仍然存在：只是需要在应用程序的特定点进行破坏。例如，因为该对象必须取消订阅某些事件或释放某些资源。

### 重生作为优化

然而，如果从另一个角度来看：实体的生命周期的开始和结束是什么？软件世界是虚拟的，是由我们自己制定的规则所决定的。换句话说，实体的生命周期开始是我们被告知可以使用实体的时间。对吗？谁阻止我们开始控制这种行为呢？让我们引入实体的重生概念：当实体完成其存在后，它会为其他人重生以重新使用。

生命周期的开始 - 理论上来说 - 是当为对象分配内存并将其转换为正确状态时。从初始化过程的最后一步开始，我们作为最容易理解的，对象的正确状态转换是由对象的构造函数负责的。它初始化了所有空字段，并赋予它们赋予它们生命的有意义的值。但是“分配内存”是什么意思呢？在C#语言的`new`操作符的术语中，这是请求为特定类型的对象分配的内存地址。换句话说...这只是一个编程上的事情 - 为你分配内存。这完全是我们每天编写的算法的结果。

我们可以创建一个新的内存管理层。在这个层中，没有垃圾收集，对象的结束也变得确定性 - 对我们来说。这种方法有不同的名称。最常见的是池化（pooling）。较少见的是缓存。也就是使用对象集合，根据请求提供对象，并在不再需要对象时将其放回集合中。

下面是一个最简单的池化示例：

```csharp
public static class ObjectsPool<T> where T : class, new()
{
    private Queue<T> objects;
    private const MinPoolSize = 32;

    static ObjectsPool()
    {
      objects = new Queue<T>(MinPoolSize);
    }

    public static T Get()
    {
      if(objects.TryDeqeue(out var instance))
      {
        return instance;
      }
      return new T();
    }

    public static void Return(T instance) => objects.Enqeue(instance);
}
```

这个池是一个“无义务”的最简单的池。也就是说，由它提供的对象不需要返回给它。如果不返回，也没有什么大不了的：它们只是会被GC收集。它的一个缺点是：`ObjectsPool<T>.Get()`可能会返回一个“脏”对象。也就是说，它已经被其他人初始化过了。要清除它，必须实现`IDisposable`。但是由于我们目前只讨论理论，所以我们不会停留在这一点上。

然而，它展示了一种新的可能性：实体的生命周期具有确定的开始时间（从池中请求）和确定的结束时间（不再需要时返回到池中），并且没有垃圾收集（引用要么来自池中，要么在使用中）。此外，如果您忘记将对象返回到池中，也没有关系：它将被垃圾收集。

但是，斯坦尼斯拉夫，请告诉我。您在这里玩弄球，编写了几个方法，并将其称为“新的内存管理层”。总的来说，这就是！我们看到了什么？可以获取新对象吗？可以！可以使用它吗？可以！可以释放内存吗？是的，也可以！那么这不就是内存管理器吗？简单？很好。愚蠢？但速度快。至于更复杂的示例，我们稍后会在使用已经掌握的理论的实践使用章节中讨论。

### 未初始化状态作为一致状态

至于结构体，关于它们的创建和销毁时间，会有很多想法。结构体的本质不仅在于将一块内存区域分割为字段，还在于作为某物的结构化部分。因为它像普通整数一样“放置”在类、变量或参数的字段中（在其声明的位置）。因此，没有为结构体专门分配内存。它只是被声明并且就这样。结构体的初始化只是将内存清零。利用这一点，可以使构造函数变得不必要。

结构体具有无法重写的默认构造函数。可以这样写：

```csharp
SomeStruct structInstance1 = default;
SomeStruct structInstance2 = new SomeStruct();
```

这将是合法的初始化，两行代码是等价的。此外，`new`操作符只是为了与类保持一致，因此可能会引起混淆：为什么首先创建，然后再复制？没必要。这个写法表示，有一块被零初始化的内存区域。然而，这个特性可以在设计结构体时使用。让我们以广为人知的`CancellationToken`结构体为例：

```csharp
struct CancellationToken
{
   private CancellationTokenSource m_source;
}

var token = default(CancellationToken);
```

这里的`token`只是被零初始化。因此，可以将`m_source == null`视为永远不会转换为`IsCancellationRequested == true`状态的令牌。也就是说，它是一个无法转换为信号状态的令牌。

结构体的生命周期与其所属实体的生命周期一起结束：当方法调用帧退出方法时，或者当类失去最后一个引用时。

### 支持.NET平台当前方法的辩护

我们从未考虑过（或者只有我一个人考虑过？）如果CLR在确定级别上释放内存会发生什么。当前的自动内存管理方法并不总是令人满意：有时候我们不喜欢在哪里分配对象和何时释放它们，因为有时候会积累太多准备释放的对象，而释放它们会拖慢整个应用程序。然而，为了支持当前方法，让我们稍微远离一下，思考一下有时候会开始想象的场景，希望能改变当前算法集合：

  - 如果我们不是在GC触发时释放对象，而是在丢失最后一个引用时释放它们，会发生什么？假设我们的代码将某个变量赋值为`null`。那么每次赋值都需要检查是赋值为`null`还是其他有效引用。如果是，我们需要确定它是否是最后一个引用。每次计算堆栈上的引用时都需要遍历所有SOH/LOH对象——这是很昂贵的。因此，每个对象都应该自己计算所有传入的引用：在每个操作上增加和减少计数器。这是额外的开销和额外的操作。此外，我们将无法压缩堆：在每次赋值之后进行压缩太昂贵了：只适用于`Sweep`方法。正如我们所看到的，很多问题已经浮出水面，更不用说细节了；
  - 如果引入`delete`操作符，以便像C++一样根据需要释放对象，还会带来析构函数作为确定性释放内存的手段：因为如果我们使用`delete`操作符释放对象，那么我们必须以同样的方式释放该对象拥有的对象。这意味着需要在对象销毁时调用的方法：类型的实例析构函数。这将增加开发的复杂性和维护程序的成本：泄漏将是常态。此外，释放内存时会出现混乱：我们失去了在最后使用点释放它的能力。也就是说，我们现在必须在严格指定的位置进行释放。
  - 如果引入混合算法：基本上与当前工作方式相同，但有一个`delete`操作符。例如，您可能会说，您希望在某个特定时刻释放用于下载图像的数据数组。因为如果我们的应用程序连续下载图像，并且它们很快变得不再需要，那么我们就会浪费大量内存，这会导致GC的调用。这对于Xamarin上的移动应用程序和“虚拟列表”控件尤其重要，在快速滚动图像时，它们会大量加载图像，然后变得不再需要。如果立即删除它们，就不会出现大量GC，这会破坏滚动动画。然而，这会给GC带来困难。手动释放内存后，最后一块内存将变得碎片化，并且可能无法容纳您请求的下一组图像数据。结果是仍然会触发GC。如果将具有手动管理的内存块放置在LOH中，则手动释放将与其算法很好地配合。然而，这仍然会导致碎片化并进一步触发完整GC。唯一正确的解决方案是使用数组池和Span/Memory来访问子范围。但那么为什么要引入`delete`？

那么，当前的解决方案是很好的，我们只需要学会正确使用它。我们稍后会讨论这个问题。

### 初步结论

从所说的一切中，我们可以看出，每个对象都有一定的存在时间。这可能看起来是一个表面上的平凡思想，但并不是那么简单：

- 重要的是要理解对象是如何在何时以及在什么条件下被创建的。因为对象的创建需要一定的时间，而且您无法预先猜测它将按照什么算法被创建：在分配上下文中有空间的情况下，通过简单地移动指针来创建对象，或者由于需要扩展或移动分配上下文而创建对象，或者由于需要压缩临时段或创建新的临时段来创建对象并进行完全的结构化。也许，在存在大量这些对象的情况下，值得考虑池化这些对象。这样，它们的创建时间将变得可预测，垃圾回收器也不会过多关注它们；
- 还应该了解对象在其生命周期内有多“受欢迎”，以及它将存在多长时间：有多少其他对象将引用它以及引用多长时间。这个因素影响垃圾收集、堆的碎片化、其他对象的创建时间，以及最有趣的是，影响垃圾收集器在标记可达对象阶段遍历对象图的时间。例如，在相同的池中，长时间存在的对象将永远进入第二代。但在初始化时，它们可能会获得对较低代的引用，这时垃圾收集器的收集机制就会启动。如果池是按需填充的（就像上面文本中的简单示例），它的对象将与其他代码创建的对象混合在一起。这将减慢对较低代的引用分析；
- 还有一个很合理且非常重要的问题：对象如何达到释放状态（释放状态听起来很悲伤）。这意味着它是否会进行确定性的销毁。例如，通过 `IDisposable.Dispose` 进行销毁；
- 并且在被垃圾收集器捕获后进行释放，从而有可能调用终结器。

这些阶段中的每一个都决定了应用程序的性能和架构的合理性。接下来，我们将逐个讨论每个阶段。