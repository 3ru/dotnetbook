# 引言

当你考虑开发任何.NET应用程序时，直到最近，你可以认为你所开发的应用程序将始终在同一平台上运行：这是在Intel技术堆栈上运行的Windows操作系统。然而，现在我们每一天都进入了一个新时代：.NET平台已经成为真正的跨平台，向所有可用的桌面操作系统延伸。这是一个美好的时代，我们的责任是不丢失方向并保持有需求的专业人员。因为当工具集变得跨平台时，我们必须开始向内部看。了解我们平台的引擎是如何工作的。以便理解为什么它在不同的系统上表现得如此或那样。

我想通过本书的页面传达的第二个思想是，即使你的服务器是超高性能的。即使它们如此快，以至于优化似乎是最后需要考虑的事情...你仍然会开始优化代码。回想一下：曾经众所周知的系统程序员比尔·盖茨曾说过，640KB的内存应该足够任何人使用。在那个时候，这是真的。如果你告诉任何人，在20年后的某个时候，一台计算机可以取代那个时代的几千台服务器，他们会告诉你：在你的时代，性能是如此之高，以至于不需要考虑优化。但是我们看到了什么？越来越多的人进入在线世界。越来越多的人开始使用智能手机，从而导致在线交易的增加。这些系统希望通过节省资源来应对不断增长的负载：在不断增长的需求下租用更少的服务器。相信我：互联网时代刚刚开始：不接受现代技术的人口将成为过去，而取而代之的是一代人，不知道其他方式。即使未来的服务器系统可以承受1000倍的负载...当然，更简单的网站可以写得很糟糕...但是如果你的目标是在顶级公司工作，你将始终从事优化工作。

[>]: 当然，关于这个问题可能有很多不同的观点。然而，根据经验和各种门户网站上的薪资统计数据，行业的发展方向正是这样。

在我看来，程序员可以分为几个类别：这种分化在某种程度上已经开始。然而，这种分割将更加明显：在我看来，最优秀的人将会脱颖而出，他们具备良好的数学基础。这些人将解决人工智能系统、神经网络、流加密和大量数据传输的问题。他们将解决短期和长期数据存储、根据模糊标准和关联标准进行高速数据检索、图像和语音的识别和合成。他们将开发监控人们生活的各个方面并通过API销售这些信息的系统。这项工作只有在了解数学基础和所使用的平台的深入了解的情况下才能完成。与此同时，大量的大学毕业生将产生过剩的供应，其中的剩余部分（希望继续从事这个职业但没有太大天赋的人）将从事“商店模板”的调整。他们将成为这项工作的专家：因为这项工作是流水线式的。而且每个类别都将有一个薪资范围。除此之外，本书的页面将帮助你进入最高薪资范围。正如通过这些知识来创造它。

[>]: 为什么这样说呢？最近我优化了代码。没有什么“特别的”，只是优化了[SMBLibrary](https://github.com/TalAloni/SMBLibrary)库。如果给它施加负载，它会在内存中创建10GB/s的数组和小对象的流量。分配一个最小大小的对象会产生2MB/s的分配。优化达到了99.9%。性能自然增加了25%。也就是说，GC占用了25%的时间：想一想。结果是，它可以更快地下载，同时需要更少的资源。

>{.big-quote} 高性能软件市场是由那些通过他们的工作自己创造需求的专业人员所创造的。

我们将逐步学习内存管理子系统，逐渐接近实践。同意吗，知识是无价的，如果不知道如何应用它们，那么它们就毫无意义。

首先，我们将证明.NET堆内存管理的算法是正确的。这将作为引言的一部分，是思维训练和接受许多人无法理解的事情的程序。然后，我们将描述内存的设备特性和组织方式。为什么呢？组织这个词是有价值的。分配内存需要时间。释放内存也需要时间。一切都需要时间：首先，我们自己需要时间。遗憾的是，性能分析器没有衡量：垃圾回收器工作了多长时间。我认为这个数字会让很多人思考。而且，这与更改语言或平台无关。在这方面，我们的一切都非常出色。而是关于如何以不同的方式工作。使这段时间成为我们自己的时间。

语言并不能提供性能。编译器才能提供性能。你知道的...只有`asm`语言可能不会被破坏。因为它是处理器的语言。但是其他所有的东西都可以写得像一个专业人士一样关注细节，也可以写得像一个学生项目一样“不要被处罚”。第二个提供性能的是我们的智慧。如果我们在循环中加入一个创建4个分配的LINQ表达式，例如，由于闭包的使用，每次循环迭代会创建大约4-6MB的流量+ 1-2个GC。如果将其改写为`for()`循环，情况将完全改变，应用程序将稍微快一些。换句话说，专业人士了解他们所使用的工具。一些编程语言、平台、操作系统和硬件的问题。

从这里可以得出结论，我是过早优化的粉丝。当然不是。我是一个坚持这样的方法论的人，即加速应用程序的一部分工作只是因为它使开发人员获得了编写最初的高效代码的经验：他们只是习惯了“自动”地做某些事情。20%的努力带来了80%的结果：记住吗？换句话说，通过记住闭包的危险、LINQ中的爱情的危险、在修改字符串时的重复和其他类似的问题，你自动地编写比没有考虑这些危险的代码更快的代码。

如果你的软件系统开始耗尽处理器或内存...微服务开始相互干扰：那么你应该振作起来，穿上防护服，进入代码优化的深渊。

在理论之后，我们将讨论实践。这一部分将分为两个部分：过早优化（即你应该习惯的东西，会带来80%的成功）和“问题开始时”。在那里，我们将讨论当我们得到的代码没有经过任何优化（即没有这80%）时的情况，以及当基本优化已经完成，我们需要做“其他事情”的情况。在实践部分，我们将学习如何编写最高效的代码。我们将从我们拥有的工具中挤取出最大的潜力，并学习在适当的时候使用它们。