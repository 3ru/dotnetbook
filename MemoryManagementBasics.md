# Основы управления памятью [В процессе]

> Если статья находится в процессе, это значит что прямо в эти минуты я ее правлю и возможно, часть информации не является достоверной

# Обзор

Когда вы думаете о разработке любого .NET приложения до недавних пор можно было себе позволить считать что приложение, которое вы делаете будет всегда работать на одной и той же платформе: это операционная система Windows, запущенная поверх технологического стека Intel. Сейчас же с каждым прожитым днем мы входим в новую эпоху: платформа .NET стала поистине кроссплатформенной, пустив новые корни в сторону всех доступных настольных операционных систем. Это - прекрасное время и наш долг сейчас не потерять нить и остаться востребованными специалистами. Ведь когда toolset становится кроссплатформенным это означает что мы обязаны начать смотреть внутрь. Изучать, как рабоатет двигатель нашей платформы. Чтобы понимать, почему тот ведет себя так или иначе на различных системах.

Подсистему управления памятью мы будем изучать по слоям. Начнем от слоя, близкого к пониманию ее работы "на пальцах" и закончим - слоем архитектуры на самом низком уровне - процессорном. Ведь чтобы до конца понимать всю проблематику работы с памятью - надо знать все, начиная от процессорных кэшей заканчивая оптимизациями работы в кучами .NET.

## Основы основ

Если взять любое приложение и попробовать грубо разделить его на две части, то получится что любое приложение состоит фактически из двух самых важных вещей: кода, которые исполняется процессором и данных, которыми этот код оперирует в своей работе. При чем если с кодом все более-менее ясно, то данные можно поделить на несколько больших секций:
 - **Thread stack** - это область памяти, которая есть у любого потока и через которую работают все вызовы всех методов плюс там же организовано хранилище для локальных переменных методов;
 - **Code Heap** - это область памяти, куда JITter складывает результаты компиляции MSIL;
 - **Small Objects Heap** - это куча маленьких объектов. Как бы это не звучало, именно так это и называется. По своей сути это - хранилище объектов, размер которых не превышает 85К байт;
 - **Large Objects Heap** - это куча больших объектов. Сюда попадают объекты, размеры которых превышают 85K байт;
 - **TypeRefs Heap** - куча Type References - описателей типов .NET - со стороны подсистемы CLR (со стороны .NET типов выступает подсистема Reflection)
 - **MethodRefs Heap** - куча Methods References - описателей методов .NET - со стороны подсистемы CLR (со стороны .NET типов выступает подсистема Reflection)
 - И многие другие

### Стек потока

> Для чего необходим стек потока, как он работает, что может содержать

### ReferenceTypes vs ValueTypes

Давайте в первую очередь поговорим про ReferenceTypes и ValueTypes. И если говорить про разницу между ними и про полезность каждого из типов, то первое, о чем я бы упомянул - так это о своих мыслях об их названии. На мой скромный взгляд, если бы их назвали ссылочные изначимые типы, то с пониманием разницы между ними все бы встало на свои места. 

> Очень часто при вопросе что такое ссылочные и значимые типы люди отвечают что ссылочные живут в куче, а значимые - в стеке. И это в корне не правильно. Это настолько маленькая часть правды, что правдой не может считаться в принципе

Также, чтобы понимать разницу между ними, давайте и будем изучать их с точки зрения разницы:

  - *Значимый тип*:  значением является **вся структура целиком**. Для *ссылочного типа* значением является **ссылка** на объект;
  - По структуре в памяти: значимые типы содержат только то, что вы указали. Ссылочные также содержат два системных поля. Первое необходимо для хранения `SyncBlockIndex`, второе - для хранения информации о типе: в том числе и о VMT (Virtual Methods Table)
  - Однако, ссылочные типы можно наследовать, переопределяя методы. Значимые типы лишены такой возможности;
  - Но чтобы выделить ссылочный тип, надо аллоцировать место в куче. Значимый тип *может* работать на стеке, не уходя в кучу, а может стать частью ссылочного типа. Это свойство может значительно повысить производительность для некоторых алгоритмов;

Однако, есть и общие черты:

  - Оба подкласса наследуют тип object, а значит - могут выступать как его представители - на полных правах

Рассмотрим каждую особенность в отдельности.

#### Копирование

Самую главную и основополагающую разницу между типами можно описать примерно так:

  - Любая переменная, поле класса/структуры или же параметр метода, которые принимают ссылочный тип, на самом деле хранят в себе **ссылку** на значение;
  - Тогда как любая переменная, поле класса/структуры или же параметр метода, которые принимают значимый тип (ValueType), на самом деле хранят в себе именно значение. Т.е. всю структуру целиком;

Что это значит для нас? Это в частности значит что любое присваивание либо прокидывание через параметр метода вызовет копирование значения. А поменяв копию, оригинал изменен не будет. При этом если вы меняете поля ссылочного типа, изменения "получают" все, кто имеют ссылку на экземпляр типа.

Это свойство рождает ряд двусмысленных на первый взгляд конструкций кода. Один из них - изменение значений в коллекциях:

```csharp
// Объявим структуру
struct ValueHolder
{
	public int Data;
}

// Создадим массив таких структур и проинициализируем поле Data = 5
var array = new []{new ValueHolder { Data = 5 }};

// Заберем по индексу структуру и в поле Data выставим 4
array[0].Data = 4;

// Проверим значение
Console.WriteLine(array[0].Data);
``` 
 
В данном коде есть маленькая хитрость. С одной стороны код выглядит так, будто мы сначала достаем экземпляр структуры, а затем у полученной копии выставляем поле Data в новое значение. А это значит что при проверке мы снова должны получить `5`. Однако все совсем не так. Все дело в том что в MSIL есть отдельная инструкция для выставление значения полей структур, находящихся в массивах. Она была введена для повышения производительности. И этот код отработает именно так как и было задумано его автором: программа выведет в консоль число `4`.

Однако стоит изменить пример так:

```csharp
// Объявим структуру
struct ValueHolder
{
	public int Data;
}

// Создадим список таких структур и проинициализируем поле Data = 5
var list = new List<ValueHolder> { new ValueHolder { Data = 5 } };

// Заберем по индексу структуру и в поле Data выставим 4
list[0].Data = 4;

// Проверим значение
Console.WriteLine(list[0].Data);
``` 
 
Как у нас ничего даже и не скомпилируется. А все потому что когда вы пишете `list[0].Data = 4`, то сначала вы получаете именно копию структуры. Вы ведь на самом деле вызываете метод экземпляра типа List<T>, который скрывается за доступом по индексу. И который в свою очередь забирает копию структуры из внутреннего массива (List<T> хранит данные в массивах), которая возвращается из метода доступа по индексу - вам. После чего вы пытаетесь модифицировать копию, которая далее нигде не используется. Это - не то чтобы ошибка, но абсолютно бессмысленный код. А компилятор, зная что люди путаются с ValTypes запрещает такое поведение. Поэтому пример должен быть переписан таким образом:


```csharp
// Объявим структуру
struct ValueHolder
{
	public int Data;
}

// Создадим список таких структур и проинициализируем поле Data = 5
var list = new List<ValueHolder> { new ValueHolder { Data = 5 } };

// Заберем по индексу структуру и в поле Data выставим 4, после чего сохраним обратно
var copy = list[0];
copy.Data = 4;
list[0] = copy;

// Проверим значение
Console.WriteLine(list[0].Data);
``` 

Несмотря на кажущееся многословие, он корректен. Когда программа отработает, в консоль выведется число `4`.

#### Переопределяемые методы и наследование

Вторая глобальная разница между ними - это отсутствие таблицы виртуальных методов в структурах. Это означает что:

  1. В структурах нельзя описать `virtual` методы, а также - переопределять их;
  2. Структуры в принципе нельзя наследовать друг от друга. Единственный способ сделать эмуляцию наследования - расположить структуру базового типа первым полем. Тогда по смещениям они будут совпадать и логически вы сделаете наследование;
  3. Структуры в отличии от классов можно передавать в unmanaged код. Я имею ввиду именно значение. Информация о методах, естественно, будет утеряна. Ведь структура - это просто отрезок памяти, заполненный данными без информации о типе. А это значит что ее можно без изменений отдавать в unmanaged методы, написанные, например, на C++. 

Отсутствие таблицы виртуальных методов хоть и отнимает у структур часть "магии", которую вносит понятие наследования, но и наделяет рядом преимуществ. Первое и самое главное уже было оговорено: мы можем легко и просто отдать во внешний мир (за пределы .NET Framework) экземпляр такой структуры. Это ведь просто участок памяти! Либо мы можем принять из unmanaged кода некий участок памяти и сделать приведение типа к нашей структуре чтобы сделать более удобный доступ к ее полям. С классами такое поведение не пройдет: у классов существует два поля, которые никому не доступны: это SyncBlockIndex и адрес таблицы виртуальных методов. Если эти два поля уйдут в unmanaged код, это станет очень опасным. Ведь с любой таблицы виртуальным методов можно умеючи достучаться до любого типа и поменять его, осуществив атаку на приложение.

Давайте докажем что это просто участок памяти без какой-либо дополнительной логики:

```csharp
unsafe void Main()
{
	int secret = 666;
	HeightHolder hh;
	hh.Height = 5;
	
	WidthHolder wh;
	unsafe
	{
		wh = *(WidthHolder *)&hh;
	}
	Console.WriteLine("Width: " + wh.Width);
	Console.WriteLine("Secret: " + wh.Secret);
}

struct WidthHolder
{
	public int Width;
	public int Secret;
}

struct HeightHolder
{
	public int Height;
}
```

В данном примере мы осуществляем недопустимую с точки зрения типов операцию: мы приводим один тип к несовместимому другому, который содержит одно лишнее поле. В методе `Main` мы вводим дополнительную переменную, значение которой по-идее секретно и не должно быть считано. Однако не так. Пример уверенно выводит на экран значение переменной метода Main(), которая не находится ни в одной из структур. Тут на вашем лице должна расплыться улыбка, а в голове промелькнуть фраза "ну ничерта себе дыра в безопасности!!!"... Но на самом деле все не так очевидно. Обезопасить свой код от вызываемого unmanaged практически не возможно. Все дело в первую очередь - в структуре стека потока (о котором мы поговорим чуть позже) и по которому можно легко уйти в вызываемый код и похимичить с локальныи переменными. Защита от такого рода атак строится другими путями. Например, на рандомизации размера кадра стека или на стирании информации о регистре EBP - для усложнения восстановления стекового кадра. Но, не будем слишком углубляться: это - тема отдельного разговора. Единственное, о чем стоит упомянуть в рамках этого примера, это почему же при том что переменная `secret` находится **перед** определением переменной `hh`, а в структуре `WidthHolder` - **после** (т.е. по сути визуально - в разных местах), ее значение прекрасно считалось. А все потому что стек растет не слева направо, а наоборот - справа налево. Т.е. переменные, объявленные первыми будут находиться по более старшим адресам, а те кто объявлены позднее - по более ранним.

##### Расширенный пример - лирическое отступление

Примерно так в стародавние времена осуществлялась атака на приложение через переписывание адресов возврата из метода на адреса своих функций. Очень примитивный пример, делающий подобные вещи:

```csharp
unsafe void Main()
{
	int secret2 = 999;
	Console.WriteLine("Entering FirstMethod");
	FirstMethod();
	Console.WriteLine("Returned from FirstMethod");
}

void FirstMethod()
{
	int secret = 666;
	Console.WriteLine("Entered FirstMethod");
	SecondMethod();
	Console.WriteLine("Returning from FirstMethod");
}

unsafe void SecondMethod()
{
	Console.WriteLine("Entered FirstMethod");
	StartingPoint sp;
	StackStructure ss;
	unsafe
	{
		ss = *(StackStructure*)&sp;
	}

	SecondMethod();
	Console.WriteLine("Returning from FirstMethod");
}

struct StackStructure
{
    // Наша переменная 
    public int a01_Self;

    // Возврат в прокси-метод, оборачивающий unsafe вызовы
    public int a02_EBP_unsafe;
    public int a03_RET_unsafe;

#if DEBUG
    public int a04_RET_to_degugger_MDA;
#endif

    // Возврат в FirstMethod()
    public int a05_RET;
    public int a06_EBP;
    public int a07_secret;

#if DEBUG
    public int a08_RET_to_debugger_MDA;
#endif

    // Возврат в Main()
    public int a09_RET_to_Main;
    public int a10_EBP;
    public int a11_secret2;
}

struct StartingPoint
{
    public int Self;
}
```

Если запускать этот код под отладчиком, то будут вставлены managed debugger assistants (MDA) вызовы. Соответственно, стек замет больше памяти и дальше идти за переменными. Если вывести значения полей `secret` и `secret2`, то мы увидем `666` и `999` соответственно. Если же мы перепишем значения более ранний RET на более поздние, мы таким образом вырежем из стека вызов метода и выход из `SecondMethod` приведет сразу к возврату в `Main`. Но это - лирическое отступление. 

#### Возможность указать положение элементов

Еще одной отличительной чертой ValTypes является возможность точно указать, по какому смещению относительно начала структуры в памяти располагается то или иное поле. Это введено для работы с внешними API, которые располагаются в unmanaged world чтобы не "отбивать" до нужного поля неиспользуемыми полями. Тут конечно же может возникнуть вопрос, почему вообще могут возникнуть поля, которые не используются вообще. И какие еще могут варианты использования смещений полей в разрезе .NET Framwork:

  - Структуры, идущие из unmanaged мира могут содержать резервные поля, которые могут быть заиспользованы в будущих версиях библиотеки. Если в мире C/C++ принято отбивать такие пропуски путем добавления полей `reserved1, reserved2, ..`, то в .NET мы имеем прекрасную возможность просто задать смещение к началу поля при помощи атрибута FieldOffsetAttribute:

```csharp
[StructLayout(LayoutKind.Explicit)]
public struct SYSTEM_INFO
{
    [FieldOffset(0)] public ulong OemId;
    [FieldOffset(8)] public ulong PageSize;
    [FieldOffset(16)] public ulong ActiveProcessorMask;
    [FieldOffset(24)] public ulong NumberOfProcessors;
    [FieldOffset(32)] public ulong ProcessorType;
}
```

  - При помощи `FieldOffsetAttribute` вы можете эмулировать такой тип из мира C/C++ как `union`. Это специальный тип, который позволяет обращаться к одним и тем же данным как к разнотипным сущностям. Давайте посмотрим на примере:
    
```csharp
// Если прочитать RGA.Value, мы прочитаем Int32 значение, которое будет аккумуляцией всех остальных полей.
// Однако если мы попробуем прочитать RGBA.R, RGBA.G, RGBA.B, RGBA.Alpha, то мы прочитаем отдельные компоненты Int32 числа
[StructLayout(LayoutKind.Explicit)]
public struct RGBA
{
    [FieldOffset(0)] public uint Value;
    [FieldOffset(0)] public byte R;
    [FieldOffset(1)] public byte G;
    [FieldOffset(2)] public byte B;
    [FieldOffset(3)] public byte Alpha;
}
```

#### Разница в аллокации 

Еще одним важным свойством обоих типов, которое является кардинально различным для них - это выделение памяти под объект / структуру. Все дело в том что для того чтобы выделить память под объект, CLR обязана для начала ответить себе на ряд вопросов. Первый - какого размера объект? Меньше он или больше 85К байт? Если меньше, то является ли количество оставшегося места в Small Objects Heap достаточным чтобы разместить объект? Если нет, запускается Garbage Collection, который для своей работы по сути должен сначала обойти граф объектов, а потом сжать их, переместив на овсободившееся место. Если и после этой операции нет места в SOH (например, ничего не было освобождено), то инициируется процесс выделения дополнительных страниц виртуальной памяти, чтобы нарастить размер Small Objects Heap. И только после того как все срастется, выделяется место под объект, а выделенный участок памяти очищается от мусора (обнуляется), размечаеся SyncBlockIndex и VirtualMethodsTable, после чего ссылка на объект возвращается пользователю. 

Если же выделяемый объект имеет размеры, превышающие 85K, то мы имеем дело с Large Objects Heap. Это, например, случай огромных строк и массивов. В этом случае мы должны найти максимально подходящий кусок памяти из списка освобожденных и если таковых нет, выделить новый участок. Эти процедуры по-умолчанию не быстрые, но мы предполагаем что с объектами такого размера мы будем работать особенно осторожно и они вне контекста данной беседы 

Т.е. для RefTypes мы имеем несколько случаев:

  - Размер RefType < 85K, место в SOH есть: выделение памяти идет достаточно быстро;
  - Размер RefType < 85K, место в SOH заканчивается: выделение памяти идет очень медленно;
  - Размер RefType > 85K, выделение памяти идет относительно медленно. А с учетом того что данные операции редки и не могут ввиду своих размеров конкурировать с ValTypes, нас это сейчас не сильно волнует.

Каков же алгоритм выделения памяти под ValueType? А нет его. Выделение памяти под ValueType не стоит абсолютно ничего. Единственное, что происходит при его "выделении" - это обнуление полей. Давайте, разберемся, почему так происходит:

  1. В случае объявления переменной в теле метода время на выделение места под структуру можно считать околонулевым. Ведь время на выделение места под локальные переменные почти не зависит от их количества;
  2. В случае размещения ValTypes в качестве полей RefTypes просто увеличит их размер. Значимый тип размещается целиком, становясь его частью;
  3. Если ValTypes передаются как параметры метода - тут, как и в случае копирования возникнет некоторая разница - в зависимоти от размера и положения параметра.

Но в любом случае это не дольше копирования из одной переменной в другую. 

#### Особенности выбора между class/struct

Почему же не выбрать ValTypes для всех типов, проектируемх в системе? Попробуем найти причины:

  1. Размещение большого количества ValTypes в стеке может привести к тому что он может быстро закончится, приведя к неуправляемому `StackOverflowException`. Стек потока весьма ограничен и не может расширяться динамически. Но, конечно же, я прежде всего имею некий фататизм в использовании больших структур и некоторой рекурсии или же просто отсутствие заботы о глубине вызовов;
  2. Стоит избегать больших массивов, внутри которых находятся большие структуры. Это может привести к уходу в Large Objects Heap и его фрагментации; 
  3. ValueTypes копируются при присваивании и изменяя одну копию, вы меняете только ее. Это поведение может оказаться не приемлимым для большинства случаев; 

**Memory Traffic**

#### Базовый тип - Object и возможность реализации интерфейсов.

### Small Objects Heap vs Large Objects Heap

> Размещение объектов по кучам, в чем разница и профиты от попадания в различные области

#### Сводная таблица свойств типов


------------
TODO:

[ ] C# 7.2 Span<T>, Memory<T>
[ ] ref var x = ref arr[0].x;
[ ] __makeref, __reftype, __refvalue, __arglist
