# Основы управления памятью

# Обзор

Когда вы думаете о разработке любого .NET приложения до недавних пор можно было себе позволить считать что приложение, которое вы делаете будет всегда работать на одной и той же платформе: это операционная система Windows, запущенная поверх технологического стека Intel. Сейчас же с каждым прожитым днем мы входим в новую эпоху: платформа .NET стала поистине кроссплатформенной, пустив новые корни в сторону всех доступных настольных операционных систем. Это - прекрасное время и наш долг сейчас не потерять нить и остаться востребованными специалистами. Ведь когда toolset становится кроссплатформенным это означает что мы обязаны начать смотреть внутрь. Изучать, как рабоатет двигатель нашей платформы. Чтобы понимать, почему тот ведет себя так или иначе на различных системах.

Подсистему управления памятью мы будем изучать по слоям. Начнем от слоя, близкого к пониманию ее работы "на пальцах" и закончим - слоем архитектуры на самом низком уровне - процессорном. Ведь чтобы до конца понимать всю проблематику работы с памятью - надо знать все, начиная от процессорных кэшей заканчивая оптимизациями работы в кучами .NET.

## Основы основ

Если взять любое приложение и попробовать грубо разделить его на две части, то получится что любое приложение состоит фактически из двух самых важных вещей: кода, которые исполняется процессором и данных, которыми этот код оперирует в своей работе. При чем если с кодом все более-менее ясно, то данные можно поделить на несколько больших секций:
 - **Thread stack** - это область памяти, которая есть у любого потока и через которую работают все вызовы всех методов плюс там же организовано хранилище для локальных переменных методов;
 - **Code Heap** - это область памяти, куда JITter складывает результаты компиляции MSIL;
 - **Small Objects Heap** - это куча маленьких объектов. Как бы это не звучало, именно так это и называется. По своей сути это - хранилище объектов, размер которых не превышает 85К байт;
 - **Large Objects Heap** - это куча больших объектов. Сюда попадают объекты, размеры которых превышают 85K байт;
 - **TypeRefs Heap** - куча Type References - описателей типов .NET - со стороны подсистемы CLR (со стороны .NET типов выступает подсистема Reflection)
 - **MethodRefs Heap** - куча Methods References - описателей методов .NET - со стороны подсистемы CLR (со стороны .NET типов выступает подсистема Reflection)
 - И многие другие

 ### ReferenceTypes vs ValueTypes

Давайте в первую очередь поговорим про ReferenceTypes и ValueTypes. И если говорить про разницу между ними и про полезность каждого из типов, то первое, о чем я бы упомянул - так это о своих мыслях об их названии. На мой скромный взгляд, если бы их назвали "by reference types" и "by value types", то с пониманием разницы между ними все бы встало на свои места. Также, чтобы понимать разницу между ними, давайте и будем изучать их с точки зрения разницы:

  - ValType - значением является **вся структура целиком**. Для RefType значением является **ссылка** на объект;
  - Структура в памяти. Во-первых ValTypes содержат только то, что вы указали. RefTypes также содержат два системных поля. Первое необходимо для хранения информации о типе: в том числе и о VMT (Virtual Methods Table)
  - Возможность указать положение элементов. ValTypes позволяют с абсолютной точностью указать смещения полей относительно начала структуры а также указать дискрентость шага размещения полей. В RefTypes это невозмозжно, т.к. бессмысленно;
  - Однако, RefTypes можно наследовать, переопределяя методы. ValTypes лишены такой возможности;
  - Но чтобы выделить RefType, надо аллоцировать место в куче. ValType *может* работать на стеке, не уходя в кучу. Это может значительно повысить производительность для некоторых алгоритмов;

Рассмотрим каждую особенность в отдельности.

#### Копирование

Самую главную и основополагающую разницу между типами можно описать примерно так:

  - Любая переменная, поле класса/структуры или же параметр метода, которые принимают ссылочный тип, на самом деле хранят в себе **ссылку** на значение;
  - Тогда как любая переменная, поле класса/структуры или же параметр метода, которые принимают значимый тип (ValueType), на самом деле хранят в себе именно значение. Т.е. всю структуру целиком;

Что это значит для нас? Это в частности значит что любое присваивание либо прокидывание через параметр метода вызовет копирование значения. А поменяв копию, оригинал изменен не будет. Однако если вы меняете поля ссылочного типа, изменения "получают" все, кто имеют ссылку на экземпляр типа.

Это свойство рождает ряд двусмысленных на первый взгляд конструкций кода. Один из них - изменение значений в коллекциях:

```csharp
// Объявим структуру
struct ValueHolder
{
	public int Data;
}

// Создадим массив таких структур и проинициализируем поле Data = 5
var array = new []{new ValueHolder { Data = 5 }};

// Заберем по индексу структуру и в поле Data выставим 4
array[0].Data = 4;

// Проверим значение
Console.WriteLine(array[0].Data);
``` 
 
В данном коде есть маленькая хитрость. С одной стороны код выглядит так, будто мы сначала достаем экземпляр структуры, а затем у полученной копии выставляем поле Data в новое значение. А это значит что при проверке мы снова должны получить `5`. Однако все совсем не так. Все дело в том что в MSIL есть отдельная инструкция для выставление значения полей структур, находящихся в массивах. Она была введена для повышения производительности. И этот код отработает именно так как и было задумано его автором: программа выведет в консоль число `4`.

Однако стоит изменить пример так:

```csharp
// Объявим структуру
struct ValueHolder
{
	public int Data;
}

// Создадим список таких структур и проинициализируем поле Data = 5
var list = new List<ValueHolder> { new ValueHolder { Data = 5 } };

// Заберем по индексу структуру и в поле Data выставим 4
list[0].Data = 4;

// Проверим значение
Console.WriteLine(list[0].Data);
``` 
 
Как у нас ничего даже и не скомпилируется. А все потому что когда вы пишете `list[0].Data = 4`, то сначала вы получаете именно копию структуры. Вы ведь на самом деле вызываете метод экземпляра типа List<T>, который скрывается за доступом по индексу. И который в свою очередь забирает копию структуры из внутреннего массива (List<T> хранит данные в массивах), которая возвращается из метода доступа по индексу - вам. После чего вы пытаетесь модифицировать копию, которая далее нигде не используется. Это - ошибка. Так делать нельзя. Поэтому пример должен быть переписан таким образом:


```csharp
// Объявим структуру
struct ValueHolder
{
	public int Data;
}

// Создадим список таких структур и проинициализируем поле Data = 5
var list = new List<ValueHolder> { new ValueHolder { Data = 5 } };

// Заберем по индексу структуру и в поле Data выставим 4, после чего сохраним обратно
var copy = list[0];
copy.Data = 4;
list[0] = copy;

// Проверим значение
Console.WriteLine(list[0].Data);
``` 

Несмотря на кажущееся многословие, он корректен. Когда программа отработает, в консоль выведется число `4`.

#### Переопределяемые методы и наследование

Вторая глобальная разница между ними - это отсутствие таблицы виртуальных методов в структурах. Это означает что:

  1. В структурах нельзя описать `virtual` методы, а также - переопределять их;
  2. Структуры в принципе нельзя наследовать друг от друга. Единственный способ сделать эмуляцию наследования - расположить структуру базового типа первым полем. Тогда по смещениям они будут совпадать и логически вы сделаете наследование;
  3. Структуры в отличии от классов можно передавать в unmanaged код. Я имею ввиду именно значение. Информация о методах, естественно, будет утеряна. Ведь структура - это просто отрезок памяти, заполненный данными без информации о типе. А это значит что ее можно без изменений отдавать в unmanaged методы, написанные, например, на C++. 

Отсутствие таблицы виртуальных методов хоть и отнимает у структур часть "магии", которую вносит понятие наследования, но и наделяет рядом преимуществ. Первое и самое главное уже было оговорено: мы можем легко и просто отдать во внешний мир (за пределы .NET Framework) экземпляр такой структуры. Это ведь просто участок памяти! Либо мы можем принять из unmanaged кода некий участок памяти и сделать приведение типа к нашей структуре чтобы сделать более удобный доступ к ее полям. С классами такое поведение не пройдет: у классов существует два поля, которые никому не доступны: это SyncBlockIndex и адрес таблицы виртуальных методов. Если эти два поля уйдут в unmanaged код, это станет очень опасным. Ведь с любой таблицы виртуальным методов можно умеючи достучаться до любого типа и поменять его, осуществив атаку на приложение.

Давайте докажем что это просто участок памяти:

```csharp
unsafe void Main()
{
	int secret = 666;
	HeightHolder hh;
	hh.Height = 5;
	
	WidthHolder wh;
	unsafe
	{
		wh = *(WidthHolder *)&hh;
	}
	Console.WriteLine("Width: " + wh.Width);
	Console.WriteLine("Secret: " + wh.Secret);
}

struct WidthHolder
{
	public int Width;
	public int Secret;
}

struct HeightHolder
{
	public int Height;
}
```

В данном примере мы осуществляем недопустимую с точки зрения типов операцию: мы приводим один тип к несовместимому другому, который содержит одно лишнее поле. В методе `Main` мы вводим дополнительную переменную, значение которой по-идее секретно и не должно быть считано. Однако не так. Пример уверенно выводит на экран значение переменной метода Main(), которая не находится ни в одной из структур. Тут на вашем лице должна расплыться улыбка, а в голове промелькнуть фраза "ну ничерта себе дыра в безопасности!!!"... Но на самом деле все не так очевидно. Обезопасить свой код от вызываемого unmanaged практически не возможно. Все дело в первую очередь - в структуре стека потока (о котором мы поговорим чуть позже) и по которому можно легко уйти в вызываемый код и похимичить с локальныи переменными. Защита от такого рода атак строится другими путями. Например, на рандомизации размера кадра стека или на стирании информации о регистра EBP - для усложнения восстановления стекового кадра. Но, не будем слишком углубляться: это - тема отдельного разговора. Замечу только, почему же переменная `secret` находится **перед** определением переменной `hh`, в структуре `WidthHolder` - **после**, но значение считалось. А все потому что стек растет не слева направо, а наоборот - справа налево. Т.е. переменные, объявленные первыми будут находиться по более старшим адресам.

Примерно так в стародавние времена осуществлялась атака на приложение через переписывание адресов возврата из метода на адреса своих функций. Очень примитивный пример, делающий подобные вещи:

```csharp
unsafe void Main()
{
	int secret2 = 999;
	Console.WriteLine("Entering FirstMethod");
	FirstMethod();
	Console.WriteLine("Returned from FirstMethod");
}

void FirstMethod()
{
	int secret = 666;
	Console.WriteLine("Entered FirstMethod");
	SecondMethod();
	Console.WriteLine("Returning from FirstMethod");
}

unsafe void SecondMethod()
{
	Console.WriteLine("Entered FirstMethod");
	StartingPoint sp;
	StackStructure ss;
	unsafe
	{
		ss = *(StackStructure*)&sp;
	}

	SecondMethod();
	Console.WriteLine("Returning from FirstMethod");
}

struct StackStructure
{
    // Наша переменная 
    public int a01_Self;

    // Возврат в прокси-метод, оборачивающий unsafe вызовы
    public int a02_EBP_unsafe;
    public int a03_RET_unsafe;

#if DEBUG
    public int a04_RET_to_degugger_MDA;
#endif

    // Возврат в FirstMethod()
    public int a05_RET;
    public int a06_EBP;
    public int a07_secret;

#if DEBUG
    public int a08_RET_to_debugger_MDA;
#endif

    // Возврат в Main()
    public int a09_RET_to_Main;
    public int a10_EBP;
    public int a11_secret2;
}

struct StartingPoint
{
    public int Self;
}
```

Если запускать этот код под отладчиком, то будут вставлены managed debugger assistants (MDA) вызовы. Соответственно, стек замет больше памяти и дальше идти за переменными. Если вывести значения полей `secret` и `secret2`, то мы увидем `666` и `999` соответственно. Если же мы перепишем значения более ранний RET на более поздние, мы таким образом вырежем из стека вызов метода и выход из `SecondMethod` приведет сразу к возврату в `Main`. Но это - лирическое отступление. 

#### Базовый тип - Object и возможность реализации интерфейсов0
