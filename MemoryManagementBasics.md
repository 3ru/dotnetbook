# Основы управления памятью [В процессе]

> Если статья находится в процессе, это значит что прямо в эти минуты я ее правлю и возможно, часть информации не является достоверной

# Обзор

Когда вы думаете о разработке любого .NET приложения до недавних пор можно было себе позволить считать что приложение, которое вы делаете будет всегда работать на одной и той же платформе: это операционная система Windows, запущенная поверх технологического стека Intel. Сейчас же с каждым прожитым днем мы входим в новую эпоху: платформа .NET стала поистине кроссплатформенной, пустив новые корни в сторону всех доступных настольных операционных систем. Это - прекрасное время и наш долг сейчас не потерять нить и остаться востребованными специалистами. Ведь когда toolset становится кроссплатформенным это означает что мы обязаны начать смотреть внутрь. Изучать, как рабоатет двигатель нашей платформы. Чтобы понимать, почему тот ведет себя так или иначе на различных системах.

Подсистему управления памятью мы будем изучать по слоям. Начнем от слоя, близкого к пониманию ее работы "на пальцах" и закончим - слоем архитектуры на самом низком уровне - процессорном. Ведь чтобы до конца понимать всю проблематику работы с памятью - надо знать все, начиная от процессорных кэшей заканчивая оптимизациями работы в кучами .NET.

## Основы основ

Если взять любое приложение и попробовать грубо разделить его на две части, то получится что любое приложение состоит фактически из двух самых важных вещей: кода, которые исполняется процессором и данных, которыми этот код оперирует в своей работе. При чем если с кодом все более-менее ясно, то данные можно поделить на несколько больших секций:
 - **Thread stack** - это область памяти, которая есть у любого потока и через которую работают все вызовы всех методов плюс там же организовано хранилище для локальных переменных методов;
 - **Code Heap** - это область памяти, куда JITter складывает результаты компиляции MSIL;
 - **Small Objects Heap** - это куча маленьких объектов. Как бы это не звучало, именно так это и называется. По своей сути это - хранилище объектов, размер которых не превышает 85К байт;
 - **Large Objects Heap** - это куча больших объектов. Сюда попадают объекты, размеры которых превышают 85K байт;
 - **TypeRefs Heap** - куча Type References - описателей типов .NET - со стороны подсистемы CLR (со стороны .NET типов выступает подсистема Reflection)
 - **MethodRefs Heap** - куча Methods References - описателей методов .NET - со стороны подсистемы CLR (со стороны .NET типов выступает подсистема Reflection)
 - И многие другие

### Стек потока

> Для чего необходим стек потока, как он работает, что может содержать

### ReferenceTypes vs ValueTypes

Давайте в первую очередь поговорим про ReferenceTypes и ValueTypes. И если говорить про разницу между ними и про полезность каждого из типов, то первое, о чем я бы упомянул - так это о своих мыслях об их названии. На мой скромный взгляд, если бы в русскоязычном сегменте их назвали ссылочные и значимые типы вместо проговаривания Vaule Type и Reference Type, то с пониманием разницы между ними все бы встало на свои места. 

> Очень часто при вопросе что такое ссылочные и значимые типы люди отвечают что ссылочные живут в куче, а значимые - в стеке. И это в корне не правильно. Это настолько маленькая часть правды, что правдой не может считаться в принципе

Также, чтобы понимать разницу между ними, давайте и будем изучать их с точки зрения разницы:

  - *Значимый тип*:  значением является **вся структура целиком**. Для *ссылочного типа* значением является **ссылка** на объект;
  - По структуре в памяти: значимые типы содержат только те данные, которые вы указали. Ссылочные также содержат два системных поля. Первое необходимо для хранения `SyncBlockIndex`, второе - для хранения информации о типе: в том числе и о VMT (Virtual Methods Table)
  - Однако, ссылочные типы можно наследовать, переопределяя методы. Значимые типы лишены такой возможности;
  - Но чтобы выделить ссылочный тип, надо аллоцировать место в куче. Значимый тип *может* работать на стеке, не уходя в кучу, а может стать частью ссылочного типа. Это свойство может значительно повысить производительность для некоторых алгоритмов;

Однако, есть и общие черты:

  - Оба подкласса наследуют тип object, а значит - могут выступать как его представители - на полных правах

Рассмотрим каждую особенность в отдельности.

#### Копирование

Самую главную и основополагающую разницу между типами можно описать примерно так:

  - Любая переменная, поле класса/структуры или же параметр метода, которые принимают ссылочный тип, на самом деле хранят в себе **ссылку** на значение;
  - Тогда как любая переменная, поле класса/структуры или же параметр метода, которые принимают значимый тип (ValueType), на самом деле хранят в себе именно значение. Т.е. всю структуру целиком;

Что это значит для нас? Это в частности значит что любое присваивание либо прокидывание через параметр метода вызовет копирование значения. А поменяв копию, оригинал изменен не будет. При этом если вы меняете поля ссылочного типа, изменения "получают" все, кто имеют ссылку на экземпляр типа. Давайте рассмотрим это на примере:

```csharp

 DateTime dt = DateTime.Now;   // Здесь сначала при вызове метода будет выделено место под переменную DateTime
                               // но заполнено оно будет нулями. Далее копируется все значение свойства Now в переменную dt
 DateTime dt2 = dt;            // Здесь значение копируется еще раз

 object obj = new object();    // Тут мы создаем объект, выделяя память в SOH и размещаем указатель на объект в переменной obj
 object obj2 = obj;            // Тут мы копируем ссылку на этот объект. Т.е. объект - один, а ссылки - две

```

Это свойство рождает ряд двусмысленных на первый взгляд конструкций кода. Один из них - изменение значений в коллекциях:

```csharp
// Объявим структуру
struct ValueHolder
{
	public int Data;
}

// Создадим массив таких структур и проинициализируем поле Data = 5
var array = new []{new ValueHolder { Data = 5 }};

// Заберем по индексу структуру и в поле Data выставим 4
array[0].Data = 4;

// Проверим значение
Console.WriteLine(array[0].Data);
``` 
 
В данном коде есть маленькая хитрость. С одной стороны код выглядит так, будто мы сначала достаем экземпляр структуры, а затем у полученной копии выставляем поле Data в новое значение. А это значит что при проверке мы снова должны получить `5`. Однако все совсем не так. Все дело в том что в MSIL есть отдельная инструкция для выставление значения полей структур, находящихся в массивах. Она была введена для повышения производительности. И этот код отработает именно так как и было задумано его автором: программа выведет в консоль число `4`.

Однако стоит изменить пример так:

```csharp
// Объявим структуру
struct ValueHolder
{
	public int Data;
}

// Создадим список таких структур и проинициализируем поле Data = 5
var list = new List<ValueHolder> { new ValueHolder { Data = 5 } };

// Заберем по индексу структуру и в поле Data выставим 4
list[0].Data = 4;

// Проверим значение
Console.WriteLine(list[0].Data);
``` 
 
Так у нас ничего даже и не скомпилируется. А все потому что когда вы пишете `list[0].Data = 4`, то сначала вы получаете именно копию структуры. Вы ведь на самом деле вызываете метод экземпляра типа List<T>, который скрывается за доступом по индексу. И который в свою очередь забирает копию структуры из внутреннего массива (List<T> хранит данные в массивах), которая возвращается из метода доступа по индексу - вам. После чего вы пытаетесь модифицировать копию, которая далее нигде не используется. Это - не то чтобы ошибка, но абсолютно бессмысленный код. А компилятор, зная что люди путаются с ValTypes запрещает такое поведение. Поэтому пример должен быть переписан таким образом:


```csharp
// Объявим структуру
struct ValueHolder
{
	public int Data;
}

// Создадим список таких структур и проинициализируем поле Data = 5
var list = new List<ValueHolder> { new ValueHolder { Data = 5 } };

// Заберем по индексу структуру и в поле Data выставим 4, после чего сохраним обратно
var copy = list[0];
copy.Data = 4;
list[0] = copy;

// Проверим значение
Console.WriteLine(list[0].Data);
``` 

Несмотря на кажущееся многословие, он корректен. Когда программа отработает, в консоль выведется число `4`.

Вторым примером я хочу показать вам что вообще понимается под "значением структуры является вся структура целиком"

```csharp
// Вариант 1
struct PersonInfo {
	pubilc int Height;
	pubilc int Width;
	pubilc int HairColor;
}

int x = 5;
PersonInfo person;
int y = 6;

// Вариант 2
int x = 5;
int Height;
int Width;
int HairColor;
int y = 6;
```

Фактически, по расположению данных в памяти оба примера идентичны. Потому как значением структуры является вся структура в целом. Куда она попала, там под себя память и определила.

```csharp
// Вариант 1
struct PersonInfo {
	pubilc int Height;
	pubilc int Width;
	pubilc int HairColor;
}

class Employee {
	public int x;
	public PersonInfo person;
	public int y;
}

// Вариант 2
class Employee {
	public int x;
	pubilc int Height;
	pubilc int Width;
	pubilc int HairColor;
	public int y;
}
```

Эти примеры также идентичны с точки зрения положения элементов в памяти, т.к. структура просто встает туда, где ее определили: среди полей класса. Я не утверждаю, что это абсолютно идентично: ведь в структуре вы можете оперировать над ее полями при помощи методов структуры.

Если говорить про ссылочные типы, то, понятное дело, для них все обстоит иначе. Сам экземпляр находится в недосягаемом SOH/LOH, а в поле класса запишется лишь значение указателя на экземпляр: 32-х или 64-разрядное число.

Последний пример, надеюсь, вас не запутает. Но мне хотелось поставить точку в этом вопросе.

```csharp
// Вариант 1
struct PersonInfo {
	pubilc int Height;
	pubilc int Width;
	pubilc int HairColor;
}

void Method(int x, PersonInfo person, int y);

// Вариант 2
void Method(int x, int HairColor, int Width, int Height, int y);
```

Вы меня поняли совершенно корректно: с точки зрения работы с памятью оба варианта будут работать одинаково (но не архитектурной! это вам не замена переменного числа аргументов!). Почему изменился порядок? Потому что параметры метода объявляются друг за другом и в этом порядке складываются в стек потока. Однако стек растет от старших адресов к младшим а это значит что порядок складывания по очереди будет отличаться от порядка складывания структуры целиком.

#### Переопределяемые методы и наследование

Вторая глобальная разница между ними - это отсутствие таблицы виртуальных методов в структурах. Это означает что:

  1. В структурах нельзя описать `virtual` методы, а также - переопределять их;
  2. Структуры в принципе нельзя наследовать друг от друга. Единственный способ сделать эмуляцию наследования - расположить структуру базового типа первым полем. Тогда по смещениям они будут совпадать, поля "отнаследованной" структуры будут располагаться после полей "базовой" и логически вы сделаете наследование;
  3. Структуры в отличии от классов можно передавать в unmanaged код. Я имею ввиду именно значение. Информация о методах, естественно, будет утеряна. Ведь структура - это просто отрезок памяти, заполненный данными без информации о типе. А это значит что ее можно без изменений отдавать в unmanaged методы, написанные, например, на C++. 

Отсутствие таблицы виртуальных методов хоть и отнимает у структур часть "магии", которую вносит понятие наследования, но и наделяет рядом преимуществ. Первое и самое главное уже было оговорено: мы можем легко и просто отдать во внешний мир (за пределы .NET Framework) экземпляр такой структуры. Это ведь просто участок памяти! Либо мы можем принять из unmanaged кода некий участок памяти и сделать приведение типа к нашей структуре чтобы сделать более удобный доступ к ее полям. С классами такое поведение не пройдет: у классов существует два поля, которые никому не доступны: это SyncBlockIndex и адрес таблицы виртуальных методов. Если эти два поля уйдут в unmanaged код, это станет очень опасным. Ведь с любой таблицы виртуальных методов можно умеючи достучаться до любого типа и поменять его, осуществив атаку на приложение.

Давайте докажем что это просто участок памяти без какой-либо дополнительной логики:

```csharp
unsafe void Main()
{
	int secret = 666;
	HeightHolder hh;
	hh.Height = 5;
	
	WidthHolder wh;
	unsafe
	{
		// Если бы у структур была информация о типе, это приведение не смотгло бы работать: 
		// CLR перед приведением типа проверила бы иерархию и не найдя в ней WidthHolder 
		// выбросила бы InvalidCastException. Но поскольку структура - просто участок памяти,
		// в unsafe мире никто не мешает вам интерпретировать его какой угодно структурой
		wh = *(WidthHolder *)&hh;
	}
	Console.WriteLine("Width: " + wh.Width);
	Console.WriteLine("Secret: " + wh.Secret);
}

struct WidthHolder
{
	public int Width;
	public int Secret;
}

struct HeightHolder
{
	public int Height;
}
```

В данном примере мы осуществляем недопустимую с точки зрения строгой типизации операцию: мы приводим один тип к несовместимому другому, который содержит одно лишнее поле. В методе `Main` мы вводим дополнительную переменную, значение которой по-идее секретно и не должно быть считано. Однако не так. Пример уверенно выводит на экран значение переменной метода Main(), которая не находится ни в одной из структур. Тут на вашем лице должна расплыться улыбка, а в голове промелькнуть фраза "ну ничерта себе дыра в безопасности!!!"... Но на самом деле все не так очевидно. Обезопасить свой код от вызываемого unmanaged практически не возможно. Все дело в первую очередь - в структуре стека потока (о котором мы поговорим чуть позже) и по которому можно легко уйти в вызываемый код и похимичить с локальныи переменными. Защита от такого рода атак строится другими путями. Например, на рандомизации размера кадра стека или на стирании информации о регистре EBP - для усложнения восстановления стекового кадра. Но, не будем слишком углубляться: это - тема отдельного разговора. Единственное, о чем стоит упомянуть в рамках этого примера, это почему же при том что переменная `secret` находится **перед** определением переменной `hh`, а в структуре `WidthHolder` - **после** (т.е. по сути визуально - в разных местах), ее значение прекрасно считалось. А все потому что стек растет не слева направо, а наоборот - справа налево. Т.е. переменные, объявленные первыми будут находиться по более старшим адресам, а те кто объявлены позднее - по более ранним.

##### Расширенный пример - лирическое отступление

Примерно так в стародавние времена осуществлялась атака на приложение через переписывание адресов возврата из метода на адреса своих функций. Очень примитивный пример, делающий подобные вещи:

```csharp
unsafe void Main()
{
	int secret2 = 999;
	Console.WriteLine("Entering FirstMethod");
	FirstMethod();
	Console.WriteLine("Returned from FirstMethod");
}

void FirstMethod()
{
	int secret = 666;
	Console.WriteLine("Entered FirstMethod");
	SecondMethod();
	Console.WriteLine("Returning from FirstMethod");
}

unsafe void SecondMethod()
{
	Console.WriteLine("Entered FirstMethod");
	StartingPoint sp;
	StackStructure ss;
	unsafe
	{
		ss = *(StackStructure*)&sp;
	}

	SecondMethod();
	Console.WriteLine("Returning from FirstMethod");
}

struct StackStructure
{
    // Наша переменная 
    public int a01_Self;

    // Возврат в прокси-метод, оборачивающий unsafe вызовы
    public int a02_EBP_unsafe;
    public int a03_RET_unsafe;

#if DEBUG
    public int a04_RET_to_degugger_MDA;
#endif

    // Возврат в FirstMethod()
    public int a05_RET;
    public int a06_EBP;
    public int a07_secret;

#if DEBUG
    public int a08_RET_to_debugger_MDA;
#endif

    // Возврат в Main()
    public int a09_RET_to_Main;
    public int a10_EBP;
    public int a11_secret2;
}

struct StartingPoint
{
    public int Self;
}
```

Если запускать этот код под отладчиком, то будут вставлены managed debugger assistants (MDA) вызовы. Соответственно, стек замет больше памяти и дальше идти за переменными. Если вывести значения полей `secret` и `secret2`, то мы увидем `666` и `999` соответственно. Если же мы перепишем значения более ранний RET на более поздние, мы таким образом вырежем из стека вызов метода и выход из `SecondMethod` приведет сразу к возврату в `Main`. Но это - лирическое отступление. 

#### Поведение при вызове экземплярных методов

Оба типа данных обладают еще одной интересной особенностью, которая не лежит на поверхности и которая может пролить еще немного света в строение обоих типов. И эта особенность связана с вызовом экземплярных методов.

```csharp

// Пример с ссылочным типом
class FooClass 
{
    private int x;

    public void ChangeTo(int val)
    {
        x = val;
    }
}

// Пример с значимым типом
struct FooStruct
{
    private int x;

    public void ChangeTo(int val)
    {
        x = val;
    }
}

FooClass klass = new FooClass();
FooStruct strukt = new FooStruct();

klass.ChangeTo(10);
strukt.ChangeTo(10);
```

Если рассуждать логически, то можно легко и просто прийти у выводу, что тело у метода компилируется одно. Т.е. нет такого что у каждого экземпляра типа компилируется свой набор методов, которые при этом совершенно одинаковые. Однако, вызванный метод прекрасно знает для какого экземпляра он вызван. Это достигается тем что первым параметром передается ссылка на экземпляр типа. Можно наш пример легко переписать и это будет совершенно идентично тому, что было написано выше (я намеренно не привожу пример с виртуальными методами. У них все по-другому):

```csharp

// Пример с ссылочным типом
class FooClass 
{
    public int x;
}

// Пример с значимым типом
struct FooStruct
{
    public int x;
}

public void ChangeTo(FooClass klass, int val)
{
    klass.x = val;
}

public void ChangeTo(ref FooStruct strukt, int val)
{
    strukt.x = val;
}

FooClass klass = new FooClass();
FooStruct strukt = new FooStruct();

ChangeTo(klass, 10);
ChangeTo(ref strukt, 10);
```

Стоит пояснить, почему я использовал ключевое слово `ref`. Если бы я его не использовал, то получилась бы ситуация, в которой я получал бы параметром метода **копию** структуры вместо оригинала, менял бы ее, а оригинал бы оставался неизменным. Мне бы пришлось возвращать измененную копию из метода вызывающей стороне (еще одно копирование), а вызывающая сторона сохранила бы это значение обратно в переменной (еще одно копирование). Вместо этого в экземплярный метод отдается указатель на структуру, по которому она и меняется. Сразу оригинал. Заметьте, что передача по указателю никак не влияет на производительность, т.к. любые операции на уровне процессора и так происходят по указателям. Т.е. ref - это из мира C#, не более того.

#### Возможность указать положение элементов

Еще одной отличительной чертой ValTypes является возможность точно указать, по какому смещению относительно начала структуры в памяти располагается то или иное поле. Это введено для работы с внешними API, которые располагаются в unmanaged world чтобы не "отбивать" до нужного поля неиспользуемыми полями. Тут конечно же может возникнуть вопрос, почему вообще могут возникнуть поля, которые не используются вообще. И какие еще могут варианты использования смещений полей в разрезе .NET Framwork:

  - Структуры, идущие из unmanaged мира могут содержать резервные поля, которые могут быть заиспользованы в будущих версиях библиотеки. Если в мире C/C++ принято отбивать такие пропуски путем добавления полей `reserved1, reserved2, ..`, то в .NET мы имеем прекрасную возможность просто задать смещение к началу поля при помощи атрибута FieldOffsetAttribute:

```csharp
[StructLayout(LayoutKind.Explicit)]
public struct SYSTEM_INFO
{
    [FieldOffset(0)] public ulong OemId;
    [FieldOffset(8)] public ulong PageSize;
    [FieldOffset(16)] public ulong ActiveProcessorMask;
    [FieldOffset(24)] public ulong NumberOfProcessors;
    [FieldOffset(32)] public ulong ProcessorType;
}
```

  - При помощи `FieldOffsetAttribute` вы можете эмулировать такой тип из мира C/C++ как `union`. Это специальный тип, который позволяет обращаться к одним и тем же данным как к разнотипным сущностям. Давайте посмотрим на примере:
    
```csharp
// Если прочитать RGA.Value, мы прочитаем Int32 значение, которое будет аккумуляцией всех остальных полей.
// Однако если мы попробуем прочитать RGBA.R, RGBA.G, RGBA.B, RGBA.Alpha, то мы прочитаем отдельные компоненты Int32 числа
[StructLayout(LayoutKind.Explicit)]
public struct RGBA
{
    [FieldOffset(0)] public uint Value;
    [FieldOffset(0)] public byte R;
    [FieldOffset(1)] public byte G;
    [FieldOffset(2)] public byte B;
    [FieldOffset(3)] public byte Alpha;
}
```

#### Разница в аллокации 

Еще одним важным свойством обоих типов, которое является кардинально различным для них - это выделение памяти под объект / структуру. Все дело в том что для того чтобы выделить память под объект, CLR обязана для начала ответить себе на ряд вопросов. Первый - какого размера объект? Меньше он или больше 85К байт? Если меньше, то является ли количество оставшегося места в Small Objects Heap достаточным чтобы разместить объект? Если нет, запускается Garbage Collection, который для своей работы по сути должен сначала обойти граф объектов, а потом сжать их, переместив на овсободившееся место. Если и после этой операции нет места в SOH (например, ничего не было освобождено), то инициируется процесс выделения дополнительных страниц виртуальной памяти, чтобы нарастить размер Small Objects Heap. И только после того как все срастется, выделяется место под объект, а выделенный участок памяти очищается от мусора (обнуляется), размечаеся SyncBlockIndex и VirtualMethodsTable, после чего ссылка на объект возвращается пользователю. 

Если же выделяемый объект имеет размеры, превышающие 85K, то мы имеем дело с Large Objects Heap. Это, например, случай огромных строк и массивов. В этом случае мы должны найти максимально подходящий кусок памяти из списка освобожденных и если таковых нет, выделить новый участок. Эти процедуры по-умолчанию не быстрые, но мы предполагаем что с объектами такого размера мы будем работать особенно осторожно и они вне контекста данной беседы 

Т.е. для RefTypes мы имеем несколько случаев:

  - Размер RefType < 85K, место в SOH есть: выделение памяти идет достаточно быстро;
  - Размер RefType < 85K, место в SOH заканчивается: выделение памяти идет очень медленно;
  - Размер RefType > 85K, выделение памяти идет относительно медленно. А с учетом того что данные операции редки и не могут ввиду своих размеров конкурировать с ValTypes, нас это сейчас не сильно волнует.

Каков же алгоритм выделения памяти под ValueType? А нет его. Выделение памяти под ValueType не стоит абсолютно ничего. Единственное, что происходит при его "выделении" - это обнуление полей. Давайте, разберемся, почему так происходит:

  1. В случае объявления переменной в теле метода время на выделение места под структуру можно считать околонулевым. Ведь время на выделение места под локальные переменные почти не зависит от их количества;
  2. В случае размещения ValTypes в качестве полей RefTypes просто увеличит их размер. Значимый тип размещается целиком, становясь его частью;
  3. Если ValTypes передаются как параметры метода - тут, как и в случае копирования возникнет некоторая разница - в зависимоти от размера и положения параметра.

Но в любом случае это не дольше копирования из одной переменной в другую. 

#### Особенности выбора между class/struct

Давайте подумаем об особенностях обоих типов, об их достоинствах и недостатках и решим, где ими лучше пользоваться. Тут, конечно же стоит вспомнить классиков, дающих утверждение что выбор в сторону значимых типов стоит дать если у нас тип не планирует быть наследуемым, он не станет меняться в течении своей жизни, а его размер не превышает 16 байт. Но не все так очевидно. Чтобы сделать полноценное сравнение нам необходимо задуматься о выборе типа с разных сторон, мысленно продумав сценарии его будущего использования. Разделить критерии выбора я предлагаю на три группы:

  - с точки зрения архитектуры системы типов, в которой ваш тип будет взаимодействовать;
  - с точки зрения подхода вас как системного программиста: каков выбор будет оптимальным с точки зрения производительности;
  - по другому просто невозможно.

Каждая сущность, которая проектируется вами должна в полной мере отражать ее назначение. И это касается не только её названия или интерфейса взаимодействия (методы, свойства), но даже выбор между значимым и ссылчным типом может быть сделан из архитектурных соображений. Давайте порассуждаем, почему с точки зрения архитектуры системы типов может быть выбрана структура, а не класс:

  1. Если наш проектируемый тип будет обладать инвариантностью по отношению к смысловой нагрузке своего состояния, то это будет значить что его состояние полностью отражает некоторый процесс или является значением чего-либо. Другими словами экземпляр типа полностью константен и не может быть изменен по своей сути. Мы можем создать на основе этой константы другой экзампляр типа, указав некоторое смещение, либо создать с нуля, указав его свойства. Но изменять его мы не имеем права. Я прошу заметить что я не имею ввиду что структура является неизменяемым типом. Вы можете менять поля как хотите. Мало того вы можете отдать ссылку на структуру в метод через `ref` параметр и получить измененные поля по выходу из метода. Однако, я про смысл с точки зрания архитектуры. Поясню на примерах:
    
      - DateTime - это структура, которая инкапсулирует в себе понятие момента времени. Она хранит эти данные в виде `uint`, однако предоставляет доступ к отдельным характеристикам момента времени как то: год, месяц, день, час, минуты, секунды, миллисекунды и даже процессорные тики. Однако исходя из того что она инкапсулирует - она не может быть изменяемой по своей природе. Мы не можем изменить конкретный момент времени чтобы он стал другим. Я не могу прожить следующую минуту своей жизни в лучший день рождения своего детства. Время неизменно. Именно поэтому выбор для типа данных может стать либо класс с readonly интерфейсом взаимодействия (который на каждое изменение свойств отдает новый экземпляр) либо структура, которая несмотря на возможность изменения полей своих экземпляров делать этого не должна: описание момента времени является *значением*. Как число. Вы же не можете залезть в структру числа и поменять его? Если вы хотите получить другой момент времени, который является смещением относительно оригинального на один день, вы просто получаете новый экземпляр структуры;
      - KeyValuePair<TKey, TValue> - это структура, инкапсулирующая в себе понятие связной пары ключ-значение. Замечу что эта структура используется только для выдачи пользователю при перечислении содержимого словаря. Почему выбрана структура с точки зрения архитектуры? Ответ прост: потому что в рамках Dictionary<T> ключ и значение неразделимые понятия. Да, внутри все устроено иначе. Внутри мы имеем сложную структуру, где ключ лежит отдельно от значения. Однако для внешнего пользователя, с точки зрения интерфейса взаимодействия и смысла самой структуры данных пара ключ-значение является неразделимым понятием. Является *значением* целиком. Если мы по этому ключу расположили другое значение это значит что изменилась вся пара. Для внешнего наблюдателя нет отдельно ключей, а отдельно - значений, они являются единым целым. Именно поэтому структура в данном случае - идеальный вариант.

  2. Если наш проектируемый тип является неотъемлимой частью внешнего типа. Но при этом он структурно неотъемлим. Т.е. было бы некорректным сказать, что внешний тип ссылается на экземпляр инкапсулируемого, но совершенно корректно - что инкапсулируемый является полноправной частью внешнего вместе со всеми своими свойствами. Как правило это используется при проектировании структур, которые являются частью другой структуры. 

      - Как, например, если взять структуру заголовка файла, было бы нечестно дать ссылку из одного файла в другой. Мол, заголовок находится в файле `header.txt`. Это было бы уместно при вставке документа в некий другой, но не вживанием файла а по относительной ссылке на файловой системе. Хороший пример - файл ярлыка ОС Windows. Однако если мы говорим о заголовке файла (например, о заголовке JPEG файла, в котором указаны размер изображения, методика сжатия, параметры съемки, коодинаты GPS и прочая метаинформация), то при проектировании типов, которые будут использованы для парсинга заголовка будет крайне полезно использовать структуры. Ведь, описав все заголовки в структурах вы получите в памяти абсолютно такое же положение всех полей как в файле. И через простое unsafe преобразование `*(Header *)readedBuffer` без каких-либо десериализаций - полностью заполненные структуры данных. 

  3. При этом заметьте, что каждый пример обладает следующим свойством: ни один из примеров не обладает свойством наследования поведения чего-либо. Мало того все эти примеры также показывают, что нет абсолютно никакого смысла наследовать поведение этих сущностей. Они полностью самодостаточны как единицы чего-либо.

Если же мы взглянем на проблематику с точки зрения эффективности работы кода, то перед нами выбор предстанет с другой стороны:
  1. Структуры необходимо выбирать если необходимо забрать из неуправляемого кода какие-то структурированные данные. Либо отдать unsafe методу структуру данных. Ссылочный тип для этого совсем не подойдет;
  2. Если тип будет часто использоваться для передачи данных в вызовах методов (пусть в качестве возвращаемых значений или как параметр метода), но при этом нет никакой необходимости ссылаться на одно значение с разных мест, то ваш выбор - структура. Как пример я могу привести кортежи. Если метод через кортеж возвращает вам несколько значений, это значит что возвращать он будет ValueTuple, который объявлен как структура. Т.е. при возврате метод не будет выделять память в куче, а использовать он будет стек потока, выделение памяти в котором не стоит вам абсолютно ничего;
  3. Если вы проектируете систему, которая создает некий больший трафик экземпляров проектируемого типа. При этом сами экземпляры имеют достаточно малый размер, а время жизни экземпляров очень короткое, то использование ссылочных типов приведет либо к использованию пула объектов либо если без пула, то к неконтролируемому замусориванию кучи. При этом часть объектов перейдет в старшие поколения, чем вызовет проседание на GC. Использование значимых типов в таких местах (если это возможно) даст прирост производительности просто потому что в SOH ничего не уйдет, а это разгрузит GC и алгоритм отработает быстрее  

Совмещая все выше-сказанное, могу предложить некоторые советы и замечания в использовании структур:  
  1. При выборе коллекций стоит избегать больших массивов, внутри которых находятся большие структуры. Это касается и тех структур данных, которые на массивах основаны (а их - большинство). Это может привести к уходу в Large Objects Heap и его фрагментации. Мало подсчитать, что если у вашей структуры 4 поля типа byte, значит займет она 4 байта. Вовсе нет. Надо понимать, что для 32-разрядных систем, каждое поле структуры будет выровнено по 4 байтам (адрес каждого поля должен делиться на 4 без остатка), а на 64-разрядных системах - по 8 байтам. Т.е. размер массива должен зависеть от размера структуры и от платформы, на которой запущено приложение. В нашем примере с 4 байтами - 85К / (от 16 до 32 байт на поле * количество полей = 4) минус размер заголовка массива: примерно от 650 до 1300 элементов на массив в зависимости от платформы (а брать понятное дело надо в меньшую сторону). Всего-то! 
  2. Также стоит отдавать себе отчет что если вы используете структуру, которая имеет некоторый достаточно большой размер как источник данных и размещаете ее в некотором классе как поле и при этом, например, одна и та же копия растиражирована на тысячу экземпляров (просто потому что вам удобно держать все под рукой), то вы тем самым увеличиваете каждый экземпляр класса на размер структуры что в конечном счете приведет к распуханию 0-го поколения и уходу в поколение 1 или даже 2. При этом если на самом деле экземпляры класса короткоживущие и вы рассчитываете на то что они будут собраны GC в нулевом поколении - за 1 мс, то будете сильно разочарованы тем что они на самом деле успели попасть в поколение 1 или даже второе. А какая, собственно, разница? Разница в том, что если поколение 0 собирается за 1 мс, то первое и второе - очень медленно и приведет к проседаниям на пустом месте;
  3. По примерно той же причине стоит избегать проброса больших структур через цепочку вызовов методов. Потому как если все начнет друг друга вызывать, то такие вызовы займут намного больше места в стеке подводя жизнь вашего приложения к смерти через `StackOverflowException`. Вторая причина - производительность. Чем больше копирований, тем медленнее все работает;

Потому в целом выбор между типами данных - достаточно не тривиальный процесс. Зачастую это может относиться к преждевременной оптимизации, чего делать не рекомендуется. Однако, если вы знаете что ваша ситуация попадает под выше-изложенные принципы, то можете спокойно делать выбор в сторону значимого типа.

**Memory Traffic**

#### Базовый тип - Object и возможность реализации интерфейсов.

#### C# 7.2 и ключевое слово ref



------------
TODO:

  - [ ] C# 7.2 Span<T>, Memory<T>
  - [ ] ref var x = ref arr[0].x;
  - [ ] __makeref, __reftype, __refvalue, __arglist
