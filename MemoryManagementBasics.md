# Основы управления памятью

# Обзор

Когда вы думаете о разработке любого .NET приложения до недавних пор можно было себе позволить считать что приложение, которое вы делаете будет всегда работать на одной и той же платформе: это операционная система Windows, запущенная поверх технологического стека Intel. Сейчас же с каждым прожитым днем мы входим в новую эпоху: платформа .NET стала поистине кроссплатформенной, пустив новые корни в сторону всех доступных настольных операционных систем. Это - прекрасное время и наш долг сейчас не потерять нить и остаться востребованными специалистами. Ведь когда toolset становится кроссплатформенным это означает что мы обязаны начать смотреть внутрь. Изучать, как рабоатет двигатель нашей платформы. Чтобы понимать, почему тот ведет себя так или иначе на различных системах.

Подсистему управления памятью мы будем изучать по слоям. Начнем от слоя, близкого к пониманию ее работы "на пальцах" и закончим - слоем архитектуры на самом низком уровне - процессорном. Ведь чтобы до конца понимать всю проблематику работы с памятью - надо знать все, начиная от процессорных кэшей заканчивая оптимизациями работы в кучами .NET.

## Основы основ

Если взять любое приложение и попробовать грубо разделить его на две части, то получится что любое приложение состоит фактически из двух самых важных вещей: кода, которые исполняется процессором и данных, которыми этот код оперирует в своей работе. При чем если с кодом все более-менее ясно, то данные можно поделить на несколько больших секций:
 - **Thread stack** - это область памяти, которая есть у любого потока и через которую работают все вызовы всех методов плюс там же организовано хранилище для локальных переменных методов;
 - **Code Heap** - это область памяти, куда JITter складывает результаты компиляции MSIL;
 - **Small Objects Heap** - это куча маленьких объектов. Как бы это не звучало, именно так это и называется. По своей сути это - хранилище объектов, размер которых не превышает 85К байт;
 - **Large Objects Heap** - это куча больших объектов. Сюда попадают объекты, размеры которых превышают 85K байт;
 - **TypeRefs Heap** - куча Type References - описателей типов .NET - со стороны подсистемы CLR (со стороны .NET типов выступает подсистема Reflection)
 - **MethodRefs Heap** - куча Methods References - описателей методов .NET - со стороны подсистемы CLR (со стороны .NET типов выступает подсистема Reflection)
 - И многие другие

 ### ReferenceTypes vs ValueTypes

Давайте в первую очередь поговорим про ReferenceTypes и ValueTypes. И если говорить про разницу между ними и про полезность каждого из типов, то первое, о чем я бы упомянул - так это о своих мыслях об их названии. На мой скромный взгляд, если бы их назвали "by reference types" и "by value types", то с пониманием разницы между ними все бы встало на свои места. Потому разницу между типами можно описать примерно так:

  - Любая переменная, поле класса/структуры или же параметр метода, которые принимают ссылочный тип, на самом деле хранят в себе **ссылку** на значение;
  - Тогда как любая переменная, поле класса/структуры или же параметр метода, которые принимают значимый тип (ValueType), на самом деле хранят в себе именно значение. Т.е. всю структуру целиком;

Что это значит для нас? Это в частности значит что любое присваивание либо прокидывание через параметр метода вызовет копирование значения. А поменяв копию, оригинал изменен не будет. Однако если вы меняете поля ссылочного типа, изменения "получают" все, кто имеют ссылку на экземпляр типа.

Это свойство рождает ряд двусмысленных на первый взгляд конструкций кода. Один из них - изменение значений в коллекциях:

```csharp
// Объявим структуру
struct ValueHolder
{
	public int Data;
}

// Создадим массив таких структур и проинициализируем поле Data = 5
var array = new []{new ValueHolder { Data = 5 }};

// Заберем по индексу структуру и в поле Data выставим 4
array[0].Data = 4;

// Проверим значение
Console.WriteLine(array[0].Data);
``` 
 
В данном коде есть аленькая хитрость. С одной стороны код выглядит так, будто мы сначала достаем экземпляр структуры, а затем у полученной копии выставляем поле Data в новое значение. А это значит что при проверке мы снова должны получить 5. Однако все совсем не так. Все дело в том что в MSIL есть отдельная инструкция а выставление значения структур, находящихся в массивах. Она была введена для повышения производительности. И этот код отработает именно так как и было задумано: программа выведет в консоль число 4.