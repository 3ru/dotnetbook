![CLR Book](./imgs/CLRBook.png)

# О книге

Эта книга задумана мной как максимально полное описание работы .NET CLR, и частично - .NET Framework и призвана в первую очередь заставить посмотреть читателя на его внутреннюю структуру под несколько другим углом: не так, как это делается обычно. Связано это в первую очередь с утверждением, которое может показаться многим очень спорным: любой разработчик обязан пройти школу C/C++. Почему? Да потому что из высокоуровневых эти языки наиболее близки к процессору и программируя на них начинаешь чувствовать работу программы сильнее. Однако, понимая, что мир устроен несколько иначе и у нас зачастую нет никакого времени изучать то, чем мы не будем напрямую пользоваться, я и решил написать эту книгу, в которой объяснение всех вопросов идет с более глубокой чем обычно - позиции и с более сложными или же попросту альтернативными примерами. Которые помимо своей стандартной миссии - на самом простом коде показать как работает тот или иной функционал - сделать реверанс в альтернативную реальность, показав что все сильно сложнее чем может показаться изначально. Зачем? Чтобы и у вас возникло чуство понимания работы CLR до последнего винтика.

*автор, Станислав Сидристый*

# Содержание

  1. Common Language Runtime
  1. [Основы менеджмента памяти: пользовательский слой](./MemoryManagementBasics.md)
      1. Стек потока
      1. Heap
      1. [RefTypes, ValueTypes, Boxing & Unboxing](./ReferenceTypesVsValueTypes.md)
      1. [Структура объектов в памяти](./ObjectsStructure.md)
      1. Small Objects Heap
      1. Large Objects Heap
      1. Garbage Collection
      1. Statics
  1. Погружаемся в систему типов
      1. Структура объектов
      1. Структура и назначение таблицы виртуальных методов
      1. Generic классы и интерфейсы: строение типов
      1. Как работает приведение типа. Скорость приведения типа.
      1. Вычисление размера ReferenceType. sizeof(reftype).
      1. TBD
  1. Слой управления памятью: как работает CLR
      1. Подробно про Small Objects Heap
          1. Пример: дамп памяти, влияние pinned objects на аллокацию
      1. Large Objects Heap
          1. Пример: как легко испортить кучу, как этого избегать
      1. Stack потока
          1. Пример: запоминаем строение стека путем его редактирования.
      1. Garbage Collection
          1. Mark & Sweep
          1. Оптимизация поколений
          1. Финлизация
          1. Проблемы, связанные с GC и финализацией
          1. [Шаблон Disposable (Disposable Design Principle)](./Disposable.md)
  1. Слой операционных систем: откуда берется память.
  1. Слой процессора: на чем все основано. Общие правила.

# Лицензия

В процессе выбора. Можно: читать, распространять с сохранением всех частей книги в той же структуре файлов, в какой книга представлена в данном месте, вносить изменения можно только через https://github.com/mumusan/dotnetbook путем создания fork и дальнейшей заявки на Pull Request в https://github.com/mumusan/dotnetbook и никак иначе.

# Благодарности

Особую благодарность выражаю своему другу Андрею Гончарову за интерес к делу, вычитку и комментарии, которые зачастую привели к переработке разделов и сделали их лучше. Также благодарю всех, кто внес вклад как в виде хороших комментариев так и в виде правок ошибок в словах и грамматике. С вами книга становится более удобной и легкой для прочтения.

Также благодарю всех тех, кто делал pull requests на github а также давал хорошие комментарии и советы - на habrahabr.ru, где производилась первичная вычитка некоторых текстов.