## Шаблон Lifetime

После того как мы так подробно рассмотрели шаблон освобождения ресурсов под названием IDisposable, мы сформулировали ряд проблемных зон этого шаблона, которые усложняют его использование. Чтобы решить эти проблемы, мы должны разработать некие противодействия, которые приведут нас к абсолютно новому и мощному инструменту. Итак, если представить что мы хотим изменить шаблон IDisposable или заменить чем-то другим, избавив при этом его от присущих ему недостатков, то что мы должны сделать? Давайте возмем группу минусов из предыдущей главы и попробуем где это вообще возможно переделать поведение так, чтобы получить плюсы:

  1. Чтобы избежать не явности объявления разрушаемости объекта, мы должны ввести новый способ уведомления о том, что класс разрушаем. Причем необходимо сделать это так, чтобы пользователь экземпляра не смог бы обойти этот механизм стороной. А какой код экземпляра типа отрабатывает в любом случае? Только конструктор. Получается, конструктор должен обладать такими свойствами, которые подскажут вызвавшему его коду что экземпляр разрушаем. И механизмов тут может быть целых два: либо имя класса должно содержать ключевое слово (например, по аналогии с `Async`, слово `Disposable`) либо должен быть некий параметр, который необходимо передать конструктору;
  2. Проблема необходимости тянуть за собой некий интерфейс чтобы разрушить сущность может быть решена выносом контроля за временем жизни сущности из самой сущности. По сути, реализацией inversion of control процесса разрушения объекта в некий сторонний механизм;
  3. Третья проблема - существование объекта после его разрушения. Её, к сожалению, решить просто не возможно: недетерминированное удаление памяти из-под объекта делает эту задачу нерешаемой;
  4. Вопрос с `explicit` реализацией `IDisposable` уходит сам собой если IDisposable не реализовывать;
  5. Проблематика разделения выделения ресурсов и их освобождения по разным методам может быть решена регистрацией ресурсов в некотором контейнере, освобождение которого будет происходить автоматически;
  6. Если говорить о сложности разрушения графа объектов, разделенных на некие слои, которые разрушаются сами по себе (например, может быть необходимо чтобы был разрушен какой-то один слой графа, а остальные должны корректно существовать дальше), отписываясь от изменений в соседних слоях, то тут можно явно выделить одну общую особенность: о чём бы ни шла речь, логически мы говорим о неких группах объектов, время жизни которых зависит друг от друга. Т.е. введя понятие зависимости времени жизни одной сущности от времени жизни другой сущности мы решим проблему очистки конкретной группы объектов не затрагивая другую группу;

Объединяя все выше сказанное, можно сделать базовый вывод что IDisposable не дает нам полной гибкости в управлении разрушением состояния объектов. Он безусловно полезен в рамках некоторой группы сценариев, но не является универсальным инструментом, который способен решить все задачи.

Давайте же найдем тот механизм, который призван помочт нам в сложных структурах объектов. Итак:

  - Наш класс либо должен как-то особо называться либо что-либо принимать в качестве параметра конструктора;
  - Процесс разрушения должен быть отдан на сторону;
  - Процесс разрушения должен быть автоматизирован;
  - Также должна существавать некая зависимость времени жизни одних объектов от времени жизни других других;
  - Мы при этом не должны каждый раз писать всю инфраструктуру, как мы делаем это для случая с IDisposable;

Поэтому:

  - Процессом разрушения должна заниматься отдельная сущность - `Lifetime`;
  - Конструктор класса должен принимать на вход экземпляр типа `Lifetime` если жизнь экземпляра нашего класса зависит от времени жизни внешнего `Lifetime` либо создавать свой собственный если зависимостей не существует;

Теперь, в новых реалиях, внешний объект будет передавать нам специальный экземпляр `Lifetime`, от которого мы будем зависеть и относительно времени жизни которого мы будем существовать. А чтобы нас разрушить, внешний тип не будет разрушать нас напрямую: вместо этого он закончит время жизни экземпляра `Lifetime`, который самостоятельно завершить время жизни всех, кто на него подписан.

Для разделения зон ответственности между участниками процесса существует три типа, определяющие понятие времени жизни:

1. `LifetimeDef`. Экземпляр данного типа хранится у того объекта, который будет владеть завершением времени жизни зависящих от него объектов;
2. `Lifetime` создается экземпляром `LifetimeDef` и будет передан всем тем, кто будет так или иначе зависеть от владельца. Сами они не могут вызвать метод `Terminate`: он доступен только у `LifetimeDef`. Забота экземпляров типов, которые получили `Lifetime` - просто накидать внутрь него действий, которые будут их разрушать.
3. `OuterLifetime` - инкапсулирует понятие readonly `Lifetime`. Другими словами, это средство защиты от конечного программиста: чтобы он не мог в переданную зависимость добавить действия по уничтожению своей. Этот тип используется, когда вы отдаете кому-либо экземпляр `Lifetime` так, чтобы относительно него можно было бы только создать новый, зависимый `LifetimeDef`. Но добавить туда свои собственные было бы не возможно. Публично, как и `Lifetime`, `OuterLifetime` содержит только свойство `IsTerminated`, однако на основе него можно создать зависимый экземпляр `LifetimeDef`, на основе которого можно осуществлять менеджмент жизни собственного экземпляра.

Рассмотрим сам интерфейс типа:

``` csharp
public class Lifetime
{
    // private List<Action> Actions { get; }

    public static Lifetime Eternal = Define("Eternal").Lifetime;

    public bool IsTerminated { get; internal set; }

    public Lifetime();

    public void Add(Action action);

    // protected void Remove(Action action);

    public void AddDisposable(IDisposable disposable);

    public void AddBracket(Action subscribe, Action unsubscribe);

    // internal void Terminate();

    public static LifetimeDef Define(string name);

    public static LifetimeDef DefineDependent(OuterLifetime parent, string name = null);

    public static Lifetime WhenAll(params OuterLifetime[] lifetimes);

    public static Lifetime WhenAny(params OuterLifetime[] lifetimes);

    // protected void CheckTerminated();
}
```