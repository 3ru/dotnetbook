# Время жизни сущностей

Один из вопросов, которые могут очень сильно влиять на производительность наших приложений - это политика выбора типа сущности  (класс или структура) и контроль за их временем жизни. Ведь архитекторы платформы не просто так выделили для нас два типа данных - это структуры и классы. Это деление в первую очередь обусловлено возможностями оптимизации приложений, архитектура которых учитывает особенности этих типов данных.

Как уже было сказано в главе [Ссылочные и значимые типы данных](../ReferenceTypesVsValueTypes.md), огромным преимуществом значимых типов данных является то, что их не надо аллоцировать. Т.е. другими словами если кто-то располагает экземпляр значимого типа в локальных переменных или параметрах метода, то расположение идёт на стеке (не выделяя дополнительной памяти в куче). Эта операция - та, о которой вам надо мечтать, т.к. именно она максимально быстра и эффективна. Если же структура располагается в полях ссылочного типа (класса), то под нее операция выделения памяти также не вызывается: ведь она является структурной частью этого ссылочного типа. Однако всё гораздо сложнее с ссылочными типами. Если речь идет о них, то мы имеем целый набор сложностей при выделении памяти под их экземпляры. Причём, что самое печальное, а может быть даже обидное - от нас почти никак не зависит, на какой из алгоритмов выделения памяти мы напоремся: на самый быстрый вариант или же на самый тяжеловесный.

## Ссылочные типы

### Общий обзор

Для целостности картины при дальнейшем чтении рассмотрим особенности времени жизни экземпляров ссылочных типов данных. Ссылочные типы обладают следующими свойствами в вопросе времени собственной жизни:

  - У ссылочных типов детерменированное начало жизни. Другими словами они порождаются тогда и только тогда, когда кто-либо запросил их создание;
  - Однако, они имеют недетерменированный освобождение: мы не знаем, когда произойдет освобождение памяти из под них. Мы не можем вызвать GC для конкретного экземпляра даже для случая с Large Objects Heap, где эта операция могла бы быть вполне уместна;

Эти два свойства дают нам немного пищи для размышлений:

  - экземпляры классов уничтожаются в случайное время в неопределенно отдаленном будущем;
  - их уничтожение обуславливается утерей ссылок на них;
  - поэтому с одной стороны это значит, что операция освобождения последней ссылки на объект превращается в детерменированную операцию "удаления" объекта из зоны видимости приложения. Он ещё есть, существует, но недосягаем для всего остального приложения;
  - однако, мы далеко не всегда в курсе, какое именно обнуление ссылки будет последним, что лишает нас свойства детерменированности в обнулении последней ссылки.

Другими словами, как ни крути, вопрос освобождения памяти, который нас как может изначально показаться не касается вообще никак, является недетерменированным. Однако, скрытость алгоритмов выделения и освобождения памяти хоть и создает временами расслабляющее действие: мы же вроде как не должны их знать. Однако, они и являются иной раз теми самыми точками, об которые наше приложения тормозит без других видимых причин.

Все начинается с операции запроса памяти от подсистемы управления памятью:

```csharp
var x = new A();
```

Эта казалось бы самая простая операция платформы .NET кроет в себе огромный пласт работы.