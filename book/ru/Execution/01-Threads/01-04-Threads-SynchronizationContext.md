# SynchronizationContext

ThreadPool -- вещь удобная и во многом всем понятная, т.к. очень простая. Однако, было бы ещё удобнее если бы можно было ввести ещё более абстрактное понятие, которое бы означало, что я хочу синхронно или же асинхронно выполнить некий код относительно своего в некотором потоке или же на некоторой группе потоков.

Примеров такого поведения в нашей жизни достаточно: взять к примеру UI. Там постоянно необходимо вызвать некий код в потоке исполнения. Но мы же не можем вызвать вот так:

```csharp
Method.InvokeOn(thread2);
```
или
```csharp
thread2.Invoke(Method)
```

Такого не бывает. Невозможно попросить поток исполнить код какого-то метода. Только ваш код может взять откуда-то переданный каким-то образом метод и его запустить.

Если бы эта задача решалась без каких-то промежуточных абстракций, мы бы завели экземпляр ConcurrentQueue, после чего клиентский код закладывал бы в эту очередь делегаты, а код компоненты, в цикле, в своём потоке, разбирал бы эту очередь и запускал делегаты на исполнение. С SyncronizationContext задача решается другим образом. SynchronizationContext выступает в роли интерфейса доступа к некоторым потокам. Как `IEnumerable<T>`, отдав кому-либо `SynchronizationContext` вы не сообщаете принимающей стороне подробности реализации. Принимающая сторона в зависимости от того, какой конкретно контекст ы передали будет планировать исполнение кода либо на ThreadPool либо на потоке UI, либо где-то ещё. 

Интерфейс планирования работы на некоторой группе потоков выглядит следующим образом:

```csharp
public class SynchronizationContext
{
  void Post(..); // (асинхронно)

  void Send(..); // (синхронно)
}
```

Этот контекст синхронизации может скрывать под собой что угодно: и ThreadPool, и любой другой пул потоков и даже всего-навсего один поток. Однако стоит упомянуть, что есть контекст синхронизации по-умолчанию и доступ к нему, к сожалению, сделан не очень удачно. Для этого необходимо создать его экземпляр:

```csharp
var ctx = new SynchronizationContext();

ctx.Post(...);
```

Контекст синхронизации по-умолчанию оборачивает ThreadPool. И поэтому когда вы планируете туда работу, делегаты исполняются в пуле потоков. Чтобы сделать свой SynchronizationContext, который, например, оборачивает ваш поток, для этого понадобится отнаследоваться от класса SynchronizationContext.

## SynchronizationContext.Current

Однако пусть мы работаем в рамках потока из пула потоков ThreadPool. Находясь в этом делегате нам сказано запустить некий делегат в рамках текущего контекста синхронизации (`SynchronizationContext.Current`). Но как он может узнать, какой из них текущий? И если я пишу свой пул потоков как мне выставить текущий контекст синхронизации для потоков, которые в нём существуют?

Выставление контекста синхронизации для текущего потока производится вызовом:

```csharp
SynchronizationContext.SetSynchronizationContext(myContext);
```

Далее, например, если создавать свой ThreadPool, то порядок был бы следующим:
- отнаследовали от SynchronizationContext свой класс, MySynchronizationContext
- конструктором приняли экземпляр класса пула потоков
- в пуле потоков при старте новых потоков в самом начале делается вызов `SynchronizationContext.SetSynchronizationContext`, который задаёт для них их контекст синхронизации
- поскольку он для всех один, то вызов `ctx.Post/.Send` перенаправится в `MySynchronizationContext`

Что это даёт? Отдав кому-либо экземпляр `SynchronizationContext` вы тем самым отдадите абстакцию "доступ к возможности запланировать в некоторую группу потоков задачу". В нашем примере под абстракцией будет скрыт наш пул потокв.


## Примеры

Хорошими примерами контекстов синхронизации, отличных от обёрток вокруг ThreadPool могут послужить обёртки вокруг UI потоков в WinForms и WPF.

Как известно, код WPF и WinForms исполняется в рамках одного-единственного UI потока. Связано это со многими причинами, но одна из них - это цикл выработки сообщений от Windows. Для этого цикла создаётся новый поток (либо используется основной поток приложения) и рамках этого потока создаётся бесконечный цикл выборки сообщений от Windows: нажали на клавишу, подвигали мышкой, drag-n-drop и прочие. Туда же через контекст синхронизации UI потока можно отдать некоторые делегаты на исполнение и тогда при очередном витке цикла выборки сообщений делегат будет выбран из очереди и исполнен в потоке UI.

Однако для некоторого алгоритма:

```csharp
public void DoSomethig(int x, int y, SynchronizationContext ctx = default)
{
    ((ctx ?? SynchronizationContext.Current) ?? new SynchronizationContext())
        .Post(() => x + y);
}
```
Решение будет следующим:
- Если передан SynchronizationContext, использовать его;
- Иначе Использовать текущий;
- Если текущий не задан -- использовать контекст по-умлочанию.

И в рамках этого контекста вызвать код сложения двух чисел:
- если этот код вызвать, передав ему контекст синхронизации UI, то сложение двух чисел произойдёт в потоке UI;
- если ничего не передавать, то будет выбран текущий;
- если текущий не установлен, будет выбран контекст по-умолчанию (API его выбора очень кривое).